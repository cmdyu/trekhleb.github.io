{"componentChunkName":"component---src-templates-post-tsx-content-file-path-src-posts-2024-api-design-x-home-timeline-index-mdx","path":"/blog/2024/api-design-x-home-timeline/","result":{"data":{"mdx":{"id":"b9189739-c623-5d99-a600-f7a827a0134e","body":"\n![X API Design](./assets/01-cover.png)\n\nWhen it comes to designing the API of the system the software engineers often consider different options like [REST vs RPC vs GraphQL](https://okso.app/showcase/system-design/page/0d03d895-b5b1-40c6-3549-945df9d98dcd) (or other hybrid approaches) to determine the best fit for a specific task or project.\n\nIn this article, we explore how the **X** (**Twitter**) home timeline (x.com/home) API is designed and what approaches they use to solve the following challenges:\n- How to fetch the list of tweets\n- How to do a sorting and pagination\n- How to return the hierarchical/linked entities (tweets, users, media)\n- How to get tweet details\n- How to \"like\" a tweet\n\nWe will only explore these challenges on the API level, treating the backend implementation as a black box, since we don't have access to the backend code itself.\n\n![X home timeline Example](./assets/02-home.jpg)\n\n> Showing the exact requests and responses here might be cumbersome and hard to follow since the deeply nested and repetitive objects are hard to read. To make it easier to see the request/response payload structure, I've made my attempt to \"type out\" the home timeline API in TypeScript. So when it comes to the request/response examples I'll use the request and response **types** instead of actual JSON objects. Also, remember that the types are simplified and many properties are omitted for brevity.\n>\n> You may find all types in [types/x.ts](https://github.com/trekhleb/trekhleb.github.io/blob/master/src/posts/2024/api-design-x-home-timeline/types/x.ts) file or at the bottom of this article in the \"Appendix: All types in one place\" section.\n\n## Fetching the list of tweets\n\n### The endpoint and request/response structure\n\nFetching the list of tweets for the home timeline starts with the `POST` request to the following endpoint:\n\n```\nPOST https://x.com/i/api/graphql/{query-id}/HomeTimeline\n```\n\nHere is a simplified **request** body type:\n\n```typescript\ntype TimelineRequest = {\n  queryId: string; // 's6ERr1UxkxxBx4YundNsXw'\n  variables: {\n    count: number; // 20\n    cursor?: string; // 'DAAACgGBGedb3Vx__9sKAAIZ5g4QENc99AcAAwAAIAIAAA'\n    seenTweetIds: string[]; // ['1867041249938530657', '1867041249938530659']\n  };\n  features: Features;\n};\n\ntype Features = {\n  articles_preview_enabled: boolean;\n  view_counts_everywhere_api_enabled: boolean;\n  // ...\n}\n```\n\nAnd here is a simplified **response** body type (we'll dive deeper into the response sub-types below):\n\n```typescript\ntype TimelineResponse = {\n  data: {\n    home: {\n      home_timeline_urt: {\n        instructions: (TimelineAddEntries | TimelineTerminateTimeline)[];\n        responseObjects: {\n          feedbackActions: TimelineAction[];\n        };\n      };\n    };\n  };\n};\n\ntype TimelineAddEntries = {\n  type: 'TimelineAddEntries';\n  entries: (TimelineItem | TimelineCursor | TimelineModule)[];\n};\n\ntype TimelineItem = {\n  entryId: string; // 'tweet-1867041249938530657'\n  sortIndex: string; // '1866561576636152411'\n  content: {\n    __typename: 'TimelineTimelineItem';\n    itemContent: TimelineTweet;\n    feedbackInfo: {\n      feedbackKeys: ActionKey[]; // ['-1378668161']\n    };\n  };\n};\n\ntype TimelineTweet = {\n  __typename: 'TimelineTweet';\n  tweet_results: {\n    result: Tweet;\n  };\n};\n\ntype TimelineCursor = {\n  entryId: string; // 'cursor-top-1867041249938530657'\n  sortIndex: string; // '1866961576813152212'\n  content: {\n    __typename: 'TimelineTimelineCursor';\n    value: string; // 'DACBCgABGedb4VyaJwuKbIIZ40cX3dYwGgaAAwAEAEEAA'\n    cursorType: 'Top' | 'Bottom';\n  };\n};\n\ntype ActionKey = string;\n```\n\nIt is interesting to note here, that \"getting\" the data is done via \"POSTing\", which is not common for the REST-like API but it is common for a GraphQL-like API.\n\n> It is worth mentioning that sometimes data fetching in RESTful APIs can still be done via `POST` requests. See the [Get Commits Batch](https://learn.microsoft.com/en-us/rest/api/azure/devops/git/commits/get-commits-batch?view=azure-devops-rest-7.2&tabs=HTTP) API from Azure as an example. However, one could arguably assume that such an approach is either an anti-pattern or a corner case to address specific RESTful limitations (e.g., URL length limits, avoiding HTTP-level caching, preventing unwanted logging of data in the URL, or other reasons).\n>\n> Most of the time, RESTful APIs are pretty picky on how HTTP methods like `GET`, `POST`, `PUT`, `PATCH`, and `DELETE` are used. What you would [typically see](https://aws.amazon.com/what-is/restful-api/) is:\n>\n> - `GET` — Fetches resources from the server (e.g., retrieves a user entity)\n> - `POST` — Creates new resources (e.g., adds a new user).\n> - `PUT` — Completely updates a resource (e.g., overwrites the entire user profile).\n> - `PATCH` — Partially updates a resource (e.g., updates the user's phone number while leaving the rest of the profile unchanged).\n> - `DELETE` — Deletes a resource (e.g., removes a user from the database).\n>\n> These constraints are considered a strength of RESTful APIs because such a standardized approach makes it easier to understand and use any RESTful API (engineers and users know what to expect). However, it can also create confusion, such as deciding which method to use when a user:\n>\n> 1. Requests a password reset, and then\n> 2. Resets the password by clicking the link in the email.\n>\n> Should this be a POST, PUT, PATCH, or something else?\n\nAdditionally, in the case of the X API, the `graphql` part of the URL indicates that X uses a GraphQL-based API.\n\nI'm using the word *\"flavor\"* here because the request body itself doesn't look like a pure [GraphQL query](https://graphql.org/learn/queries/), where we may describe the required response structure, listing all the properties we want to fetch:\n\n```graphql\n# An example of a pure GraphQL request structure that is *not* being used in the X API.\n{\n  tweets {\n    id\n    description\n    created_at\n    medias {\n      kind\n      url\n      # ...\n    }\n    author {\n      id\n      name\n      # ...\n    }\n    # ...\n  }\n}\n```\n\nThe assumption here is that the home timeline API is not a pure GraphQL API, but is a **mix of several approaches**. Passing the parameters in a POST request like this seems closer to the \"functional\" RPC call. But at the same time, it seems like the GraphQL features might be used somewhere on the backend behind the *HomeTimeline* endpoint handler/controller. A mix like this might also be caused by a legacy code or some sort of ongoing migration. But again, these are just my speculations.\n\nYou may also notice that the same `TimelineRequest.queryId` is used in the API URL as well as in the API request body. This queryId is most probably generated on the backend, then it gets embedded in the `main.js` bundle, and then it is used when fetching the data from the backend. It is hard for me to understand how this `queryId` is used exactly since X's backend is a black box in our case. But, again, the speculation here might be that, it might be needed for some sort of performance optimization (re-using some pre-computed query results?), caching (Apollo related?), debugging (join logs by queryId?), or tracking/tracing purposes.\n\nOne assumption here is that the actual GraphQL query might be just prepared (but not yet executed) on the server side and mapped to a specific `queryId`. Then, the client (i.e. the browser or the mobile app) will send the `queryId` along with some additional \"dynamic\" data (like pagination cursor) to the backend, which, in turn, would fetch the query by its `queryId`, augment the prepared query with a dynamic data and then would finally execute the actual GraphQL query. This may be useful, for example, in the following cases:\n\n- it may potentially save some traffic, since less data is being transmitted with each query,\n- it may take into account some security considerations and hide some query parameters or details from the user (the \"secret\" parameters will be attached on the backend side and are not visible in the browser's network tab),\n- it may allow the backend to have a full control over the actual GraphQL query structure\n  - there are many times when query structure may need to be changed (i.e. A/B testing, API v1->v2 migration, maybe some performance issues mitigation (like having a default sorting on field `A` is faster than on field `B`), and other cases)\n  - if such query adaptation may be performed solely on the backend without involving the web and mobile (iOS + Android) teams, it may have some benefits: 1 team (backend) and 1 deployment (backend service), instead of 3 teams (frontend, backend, mobile) and 4 deployments (backend, frontend, iOS, Android). This would require a generation of a new `queryId` and some mechanisms to pass this new `queryId` to the clients without them being re-build every time though.\n- caching (not on the API-gateway level)?\n\nBut again, the points above, are just mine speculations and assumptions. I can't be sure that this is how the `queryId` is used by X team.\n\nIt is also interesting to note, that the `TimelineResponse` contains not a list of tweets, but rather a list of **instructions**, like *\"add a tweet to the timeline\"* (see the `TimelineAddEntries` type), or *\"terminate the timeline\"* (see the `TimelineTerminateTimeline` type).\n\nThe `TimelineAddEntries` instruction itself may also contain different types of entities:\n- Tweets — see the `TimelineItem` type\n- Cursors — see the `TimelineCursor` type\n- Conversations/comments/threads — see the `TimelineModule` type\n\n```typescript\ntype TimelineResponse = {\n  data: {\n    home: {\n      home_timeline_urt: {\n        instructions: (TimelineAddEntries | TimelineTerminateTimeline)[]; // <-- Here\n        // ...\n      };\n    };\n  };\n};\n\ntype TimelineAddEntries = {\n  type: 'TimelineAddEntries';\n  entries: (TimelineItem | TimelineCursor | TimelineModule)[]; // <-- Here\n};\n```\n\nThis is interesting from the extendability point of view since it allows a wider variety of what can be rendered in the home timeline without tweaking the API too much.\n\n### Pagination\n\nThe `TimelineRequest.variables.count` property sets how many tweets we want to fetch at once (per page). The default is 20. However, more than 20 tweets can be returned in the `TimelineAddEntries.entries` array. For example, the array might contain 37 entries for the first page load, because it includes tweets (29), pinned tweets (1), promoted tweets (5), and pagination cursors (2). I'm not sure why there are  29 regular tweets with the requested count of 20 though.\n\nThe `TimelineRequest.variables.cursor` is responsible for the cursor-based pagination.\n\n> \"**Cursor pagination** is most often used for real-time data due to the frequency new records are added and because when reading data you often see the latest results first. It eliminates the possibility of skipping items and displaying the same item more than once. In cursor-based pagination, a constant pointer (or cursor) is used to keep track of where in the data set the next items should be fetched from.\" See the [Offset pagination vs Cursor pagination](https://stackoverflow.com/questions/55744926/offset-pagination-vs-cursor-pagination) thread for the context.\n\nWhen fetching the list of tweets for the first time the `TimelineRequest.variables.cursor` is empty, since we want to fetch the top tweets from the default (most probably pre-computed) list of personalized tweets.\n\nHowever, in the response, along with the tweet data, the backend also returns the cursor entries. Here is the response type hierarchy: `TimelineResponse → TimelineAddEntries → TimelineCursor`:\n\n```typescript\ntype TimelineResponse = {\n  data: {\n    home: {\n      home_timeline_urt: {\n        instructions: (TimelineAddEntries | TimelineTerminateTimeline)[]; // <-- Here\n        // ...\n      };\n    };\n  };\n};\n\ntype TimelineAddEntries = {\n  type: 'TimelineAddEntries';\n  entries: (TimelineItem | TimelineCursor | TimelineModule)[]; // <-- Here (tweets + cursors)\n};\n\ntype TimelineCursor = {\n  entryId: string;\n  sortIndex: string;\n  content: {\n    __typename: 'TimelineTimelineCursor';\n    value: string; // 'DACBCgABGedb4VyaJwuKbIIZ40cX3dYwGgaAAwAEAEEAA' <-- Here\n    cursorType: 'Top' | 'Bottom';\n  };\n};\n```\n\nEvery page contains the list of tweets along with \"top\" and \"bottom\" cursors:\n\n![Cursors](./assets/03-cursors.jpg)\n\nAfter the page data is loaded, we can go from the current page in both directions and fetch either the \"previous/older\" tweets using the \"bottom\" cursor or the \"next/newer\" tweets using the \"top\" cursor. My assumption is that fetching the \"next\" tweets using the \"top\" cursor happens in two cases: when the new tweets were added while the user is still reading the current page, or when the user starts scrolling the feed upwards (and there are no cached entries or if the previous entries were deleted for the performance reasons).\n\nThe X's cursor itself might look like this: `DAABCgABGemI6Mk__9sKAAIZ6MSYG9fQGwgAAwAAAAIAAA`. In some API designs, the cursor may be a Base64 encoded string that contains the id of the last entry in the list, or the timestamp of the last seen entry. For example: `eyJpZCI6ICIxMjM0NTY3ODkwIn0= --> {\"id\": \"1234567890\"}`, and then, this data is used to query the database accordingly. In the case of X API, it looks like the cursor is being Base64 decoded into some custom binary sequence that might require some further decoding to get any meaning out of it (i.e. via the Protobuf message definitions). Since we don't know if it is a `.proto` encoding and also we don't know the `.proto` message definition we may just assume that the backend knows how to query the next batch of tweets based on the cursor string.\n\nThe `TimelineResponse.variables.seenTweetIds` parameter is used to inform the server about which tweets from the currently active page of the infinite scrolling the client has already seen. This most probably helps ensure that the server does not include duplicate tweets in subsequent pages of results.\n\n## Linked/hierarchical entities\n\nOne of the challenges to be solved in the APIs like home timeline (or Home Feed) is to figure out how to return the linked or hierarchical entities (i.e. `tweet → user`, `tweet → media`, `media → author`, etc):\n- Should we only return the list of tweets first and then fetch the dependent entities (like user details) in a bunch of separate queries on-demand?\n- Or should we return all the data at once, increasing the time and the size of the first load, but saving the time for all subsequent calls?\n  - Do we need to normalize the data in this case to reduce the payload size (i.e. when the same user is an author of many tweets and we want to avoid repeating the user data over and over again in each tweet entity)?\n- Or should it be a combination of the approaches above?\n\nLet's see how X handles it.\n\nEarlier in the `TimelineTweet` type the `Tweet` sub-type was used. Let's see how it looks:\n\n```typescript\nexport type TimelineResponse = {\n  data: {\n    home: {\n      home_timeline_urt: {\n        instructions: (TimelineAddEntries | TimelineTerminateTimeline)[]; // <-- Here\n        // ...\n      };\n    };\n  };\n};\n\ntype TimelineAddEntries = {\n  type: 'TimelineAddEntries';\n  entries: (TimelineItem | TimelineCursor | TimelineModule)[]; // <-- Here\n};\n\ntype TimelineItem = {\n  entryId: string;\n  sortIndex: string;\n  content: {\n    __typename: 'TimelineTimelineItem';\n    itemContent: TimelineTweet; // <-- Here\n    // ...\n  };\n};\n\ntype TimelineTweet = {\n  __typename: 'TimelineTweet';\n  tweet_results: {\n    result: Tweet; // <-- Here\n  };\n};\n\n// A Tweet entity\ntype Tweet = {\n  __typename: 'Tweet';\n  core: {\n    user_results: {\n      result: User; // <-- Here (a dependent User entity)\n    };\n  };\n  legacy: {\n    full_text: string;\n    // ...\n    entities: { // <-- Here (a dependent Media entities)\n      media: Media[];\n      hashtags: Hashtag[];\n      urls: Url[];\n      user_mentions: UserMention[];\n    };\n  };\n};\n\n// A User entity\ntype User = {\n  __typename: 'User';\n  id: string; // 'VXNlcjoxNDUxM4ADSG44MTA4NDc4OTc2'\n  // ...\n  legacy: {\n    location: string; // 'San Francisco'\n    name: string; //  'John Doe'\n    // ...\n  };\n};\n\n// A Media entity\ntype Media = {\n  // ...\n  source_user_id_str: string; // '1867041249938530657'  <-- Here (the dependant user is being mentioned by its ID)\n  url: string; // 'https://t.co/X78dBgtrsNU'\n  features: {\n    large: { faces: FaceGeometry[] };\n    medium: { faces: FaceGeometry[] };\n    small: { faces: FaceGeometry[] };\n    orig: { faces: FaceGeometry[] };\n  };\n  sizes: {\n    large: MediaSize;\n    medium: MediaSize;\n    small: MediaSize;\n    thumb: MediaSize;\n  };\n  video_info: VideoInfo[];\n};\n```\n\nWhat's interesting here is that most of the dependent data like `tweet → media` and `tweet → author` is embedded into the response on the first call (no subsequent queries).\n\nAlso, the `User` and `Media` connections with `Tweet` entities are not normalized (if two tweets have the same author, their data will be repeated in each tweet object). But it seems like it should be ok, since in the scope of the home timeline for a specific user the tweets will be authored by many authors and repetitions are possible but sparse.\n\nMy assumption was that the `UserTweets` API (that we don't cover here), which is responsible for fetching the tweets of *one particular user* will handle it differently, but, apparently, it is not the case. The `UserTweets` returns the list of tweets of the same user and embeds the same user data over and over again for each tweet. It's interesting. Maybe the simplicity of the approach beats some data size overhead (maybe user data is considered pretty small in size). I'm not sure.\n\nAnother observation about the entities' relationship is that the `Media` entity also has a link to the `User` (the author). But it does it not via direct entity embedding as the `Tweet` entity does, but rather it links via the `Media.source_user_id_str` property.\n\nThe \"comments\" (which are also the \"tweets\" by their nature) for each \"tweet\" in the home timeline are not fetched at all. To see the tweet thread the user must click on the tweet to see its detailed view. The tweet thread will be fetched by calling the `TweetDetail` endpoint (more about it in the \"Tweet detail page\" section below).\n\nAnother entity that each `Tweet` has is `FeedbackActions` (i.e. \"Recommend less often\" or \"See fewer\"). The way the `FeedbackActions` are stored in the response object is different from the way the `User` and `Media` objects are stored. While the `User` and `Media` entities are part of the `Tweet`, the `FeedbackActions` are stored separately in `TimelineItem.content.feedbackInfo.feedbackKeys` array and are linked via the `ActionKey`. That was a slight surprise for me since it doesn't seem to be the case that any action is re-usable. It looks like one action is used for one particular tweet only. So it seems like the `FeedbackActions` could be embedded into each tweet in the same way as `Media` entities. But I might be missing some hidden complexity here (like the fact that each action can have children actions).\n\nMore details about the actions are in the \"Tweet actions\" section below.\n\n## Sorting\n\nThe sorting order of the timeline entries is defined by the backend via the `sortIndex` properties:\n\n```typescript\ntype TimelineCursor = {\n  entryId: string;\n  sortIndex: string; // '1866961576813152212' <-- Here\n  content: {\n    __typename: 'TimelineTimelineCursor';\n    value: string;\n    cursorType: 'Top' | 'Bottom';\n  };\n};\n\ntype TimelineItem = {\n  entryId: string;\n  sortIndex: string; // '1866561576636152411' <-- Here\n  content: {\n    __typename: 'TimelineTimelineItem';\n    itemContent: TimelineTweet;\n    feedbackInfo: {\n      feedbackKeys: ActionKey[];\n    };\n  };\n};\n\ntype TimelineModule = {\n  entryId: string;\n  sortIndex: string; // '73343543020642838441' <-- Here\n  content: {\n    __typename: 'TimelineTimelineModule';\n    items: {\n      entryId: string,\n      item: TimelineTweet,\n    }[],\n    displayType: 'VerticalConversation',\n  };\n};\n```\n\nThe `sortIndex` itself might look something like this `'1867231621095096312'`. It likely corresponds directly to or is derived from a [Snowflake ID](https://en.wikipedia.org/wiki/Snowflake_ID).\n\n> Actually most of the IDs you see in the response (tweet IDs) follow the \"Snowflake ID\" convention and look like `'1867231621095096312'`.\n\nIf this is used to sort entities like tweets, the system leverages the inherent chronological sorting of Snowflake IDs. Tweets or objects with a higher sortIndex value (a more recent timestamp) appear higher in the feed, while those with lower values (an older timestamp) appear lower in the feed.\n\nHere’s the step-by-step decoding of the Snowflake ID (in our case the `sortIndex`) `1867231621095096312`:\n\n- Extract the **Timestamp**:\n  - The timestamp is derived by right-shifting the Snowflake ID by 22 bits (to remove the lower 22 bits for data center, worker ID, and sequence): `1867231621095096312 → 445182709954`\n- Add **Twitter's Epoch**:\n  - Adding Twitter's custom epoch (1288834974657) to this timestamp gives the UNIX timestamp in milliseconds: `445182709954 + 1288834974657 → 1734017684611ms`\n- Convert to a **human-readable date**:\n  - Converting the UNIX timestamp to a UTC datetime gives: `1734017684611ms → 2024-12-12 15:34:44.611 (UTC)`\n\nSo we can assume here that the tweets in the home timeline are sorted chronologically.\n\n## Tweet actions\n\nEach tweet has an \"Actions\" menu.\n\n![Actions](./assets/04-actions.jpg)\n\nThe actions for each tweet are coming from the backend in a `TimelineItem.content.feedbackInfo.feedbackKeys` array and are linked with the tweets via the `ActionKey`:\n\n```typescript\ntype TimelineResponse = {\n  data: {\n    home: {\n      home_timeline_urt: {\n        instructions: (TimelineAddEntries | TimelineTerminateTimeline)[];\n        responseObjects: {\n          feedbackActions: TimelineAction[]; // <-- Here\n        };\n      };\n    };\n  };\n};\n\ntype TimelineItem = {\n  entryId: string;\n  sortIndex: string;\n  content: {\n    __typename: 'TimelineTimelineItem';\n    itemContent: TimelineTweet;\n    feedbackInfo: {\n      feedbackKeys: ActionKey[]; // ['-1378668161'] <-- Here\n    };\n  };\n};\n\ntype TimelineAction = {\n  key: ActionKey; // '-609233128'\n  value: {\n    feedbackType: 'NotRelevant' | 'DontLike' | 'SeeFewer'; // ...\n    prompt: string; // 'This post isn’t relevant' | 'Not interested in this post' | ...\n    confirmation: string; // 'Thanks. You’ll see fewer posts like this.'\n    childKeys: ActionKey[]; // ['1192182653', '-1427553257'], i.e. NotInterested -> SeeFewer\n    feedbackUrl: string; // '/2/timeline/feedback.json?feedback_type=NotRelevant&action_metadata=SRwW6oXZadPHiOczBBaAwPanEwE%3D'\n    hasUndoAction: boolean;\n    icon: string; // 'Frown'\n  };\n};\n```\n\nIt is interesting here that this flat array of actions is actually a tree (or a graph? I didn't check), since each action may have child actions (see the `TimelineAction.value.childKeys` array). This makes sense, for example, when after the user clicks on the **\"Don't Like\"** action, the follow-up might be to show the **\"This post isn’t relevant\"** action, as a way of explaining why the user doesn't like the tweet.\n\n## Tweet detail page\n\nOnce the user would like to see the tweet detail page (i.e. to see the thread of comments/tweets), the user clicks on the tweet and the `GET` request to the following endpoint is performed:\n\n```\nGET https://x.com/i/api/graphql/{query-id}/TweetDetail?variables={\"focalTweetId\":\"1867231621095096312\",\"referrer\":\"home\",\"controller_data\":\"DACABBSQ\",\"rankingMode\":\"Relevance\",\"includePromotedContent\":true,\"withCommunity\":true}&features={\"articles_preview_enabled\":true}\n```\n\nI was curious here why the list of tweets is being fetched via the `POST` call, but each tweet detail is fetched via the `GET` call. Seems inconsistent. Especially keeping in mind that similar query parameters like `query-id`, `features`, and others this time are passed in the URL and not in the request body. The response format is also similar and is re-using the types from the list call. I'm not sure why is that. But again, I'm sure I might be might be missing some background complexity here.\n\nHere are the simplified response body types:\n\n```typescript\ntype TweetDetailResponse = {\n  data: {\n    threaded_conversation_with_injections_v2: {\n      instructions: (TimelineAddEntries | TimelineTerminateTimeline)[],\n    },\n  },\n}\n\ntype TimelineAddEntries = {\n  type: 'TimelineAddEntries';\n  entries: (TimelineItem | TimelineCursor | TimelineModule)[];\n};\n\ntype TimelineTerminateTimeline = {\n  type: 'TimelineTerminateTimeline',\n  direction: 'Top',\n}\n\ntype TimelineModule = {\n  entryId: string; // 'conversationthread-58668734545929871193'\n  sortIndex: string; // '1867231621095096312'\n  content: {\n    __typename: 'TimelineTimelineModule';\n    items: {\n      entryId: string, // 'conversationthread-1866876425669871193-tweet-1866876038930951193'\n      item: TimelineTweet,\n    }[], // Comments to the tweets are also tweets\n    displayType: 'VerticalConversation',\n  };\n};\n```\n\nThe response is pretty similar (in its types) to the list response, so we won't for too long here.\n\nOne interesting nuance is that the \"comments\" (or conversations) of each tweet are actually other tweets (see the `TimelineModule` type). So the tweet thread looks very similar to the home timeline feed by showing the list of `TimelineTweet` entries. This looks elegant. A good example of a universal and re-usable approach to the API design.\n\n## Liking the tweet\n\nWhen a user likes the tweet, the `POST` request to the following endpoint is being performed:\n\n```\nPOST https://x.com/i/api/graphql/{query-id}/FavoriteTweet\n```\n\nHere is the **request** body types:\n\n```typescript\ntype FavoriteTweetRequest = {\n  variables: {\n    tweet_id: string; // '1867041249938530657'\n  };\n  queryId: string; // 'lI07N61twFgted2EgXILM7A'\n};\n```\n\nHere is the **response** body types:\n\n```typescript\ntype FavoriteTweetResponse = {\n  data: {\n    favorite_tweet: 'Done',\n  }\n}\n```\n\nLooks straightforward and also resembles the RPC-like approach to the API design.\n\n## Conclusion\n\nWe have touched on some basic parts of the home timeline API design by looking at X's API example. I made some assumptions along the way to the best of my knowledge. I believe some things I might have interpreted incorrectly and I might have missed some complex nuances. But even with that in mind, I hope you got some useful insights from this high-level overview, something that you could apply in your next API Design session.\n\nInitially, I had a plan to go through similar top-tech websites to get some insights from Facebook, Reddit, YouTube, and others and to collect battle-tested best practices and solutions. I'm not sure if I'll find the time to do that. Will see. But it could be an interesting exercise.\n\n## UPD (2025-12-18)\n\n> Based on the X thread from [@UriGoldshtein](https://x.com/UriGoldshtein/status/1869403702668214451)\n>\n> \"He (trekhleb) says they are not using \"pure GraphQL\" because they are not sending the query over the network - but that's exactly how you should use GraphQL - using \"Persisted/Trusted queries\". That makes GraphQL a developer time tool, not a runtime feature. Which means you can basically think of each query is a REST endpoint, but instead of writing code to create controllers and endpoints, it is done automatically for you using static, type-safe, graph queries that at build time turn into endpoints and a secure allow list. It also means you don't need to upload the whole query body, just the query id. You 100% should use trusted documents for you GraphQL API and X is obviously doing it!\"\n>\n> \"He (trekhleb) was asking \"I was curious here why the list of tweets is being fetched via the POST call, but each tweet detail is fetched via the GET call\". My uneducated guess is that because a single tweet is more static content compared to the list of tweets that might change based on many things, with GET it could use simple, popular and existing caching mechanisms. That is another misconception about GraphQL - it can use both GET and POST and as we discussed before - if you use (and you should) trust documents, you basically create GET endpoints that are easily cacheable.\"\n\n## Appendix: All types in one place\n\nFor the reference, I'm adding all types in one go here. You may also find all types in [types/x.ts](https://github.com/trekhleb/trekhleb.github.io/blob/master/src/posts/2024/api-design-x-home-timeline/types/x.ts) file.\n\n```typescript\n/**\n * This file contains the simplified types for X's (Twitter's) home timeline API.\n *\n * These types are created for exploratory purposes, to see the current implementation\n * of the X's API, to see how they fetch Home Feed, how they do a pagination and sorting,\n * and how they pass the hierarchical entities (posts, media, user info, etc).\n *\n * Many properties and types are omitted for simplicity.\n */\n\n// POST https://x.com/i/api/graphql/{query-id}/HomeTimeline\nexport type TimelineRequest = {\n  queryId: string; // 's6ERr1UxkxxBx4YundNsXw'\n  variables: {\n    count: number; // 20\n    cursor?: string; // 'DAAACgGBGedb3Vx__9sKAAIZ5g4QENc99AcAAwAAIAIAAA'\n    seenTweetIds: string[]; // ['1867041249938530657', '1867041249938530658']\n  };\n  features: Features;\n};\n\n// POST https://x.com/i/api/graphql/{query-id}/HomeTimeline\nexport type TimelineResponse = {\n  data: {\n    home: {\n      home_timeline_urt: {\n        instructions: (TimelineAddEntries | TimelineTerminateTimeline)[];\n        responseObjects: {\n          feedbackActions: TimelineAction[];\n        };\n      };\n    };\n  };\n};\n\n// POST https://x.com/i/api/graphql/{query-id}/FavoriteTweet\nexport type FavoriteTweetRequest = {\n  variables: {\n    tweet_id: string; // '1867041249938530657'\n  };\n  queryId: string; // 'lI07N6OtwFgted2EgXILM7A'\n};\n\n// POST https://x.com/i/api/graphql/{query-id}/FavoriteTweet\nexport type FavoriteTweetResponse = {\n  data: {\n    favorite_tweet: 'Done',\n  }\n}\n\n// GET https://x.com/i/api/graphql/{query-id}/TweetDetail?variables={\"focalTweetId\":\"1867041249938530657\",\"referrer\":\"home\",\"controller_data\":\"DACABBSQ\",\"rankingMode\":\"Relevance\",\"includePromotedContent\":true,\"withCommunity\":true}&features={\"articles_preview_enabled\":true}\nexport type TweetDetailResponse = {\n  data: {\n    threaded_conversation_with_injections_v2: {\n      instructions: (TimelineAddEntries | TimelineTerminateTimeline)[],\n    },\n  },\n}\n\ntype Features = {\n  articles_preview_enabled: boolean;\n  view_counts_everywhere_api_enabled: boolean;\n  // ...\n}\n\ntype TimelineAction = {\n  key: ActionKey; // '-609233128'\n  value: {\n    feedbackType: 'NotRelevant' | 'DontLike' | 'SeeFewer'; // ...\n    prompt: string; // 'This post isn’t relevant' | 'Not interested in this post' | ...\n    confirmation: string; // 'Thanks. You’ll see fewer posts like this.'\n    childKeys: ActionKey[]; // ['1192182653', '-1427553257'], i.e. NotInterested -> SeeFewer\n    feedbackUrl: string; // '/2/timeline/feedback.json?feedback_type=NotRelevant&action_metadata=SRwW6oXZadPHiOczBBaAwPanEwE%3D'\n    hasUndoAction: boolean;\n    icon: string; // 'Frown'\n  };\n};\n\ntype TimelineAddEntries = {\n  type: 'TimelineAddEntries';\n  entries: (TimelineItem | TimelineCursor | TimelineModule)[];\n};\n\ntype TimelineTerminateTimeline = {\n  type: 'TimelineTerminateTimeline',\n  direction: 'Top',\n}\n\ntype TimelineCursor = {\n  entryId: string; // 'cursor-top-1867041249938530657'\n  sortIndex: string; // '1867231621095096312'\n  content: {\n    __typename: 'TimelineTimelineCursor';\n    value: string; // 'DACBCgABGedb4VyaJwuKbIIZ40cX3dYwGgaAAwAEAEEAA'\n    cursorType: 'Top' | 'Bottom';\n  };\n};\n\ntype TimelineItem = {\n  entryId: string; // 'tweet-1867041249938530657'\n  sortIndex: string; // '1867231621095096312'\n  content: {\n    __typename: 'TimelineTimelineItem';\n    itemContent: TimelineTweet;\n    feedbackInfo: {\n      feedbackKeys: ActionKey[]; // ['-1378668161']\n    };\n  };\n};\n\ntype TimelineModule = {\n  entryId: string; // 'conversationthread-1867041249938530657'\n  sortIndex: string; // '1867231621095096312'\n  content: {\n    __typename: 'TimelineTimelineModule';\n    items: {\n      entryId: string, // 'conversationthread-1867041249938530657-tweet-1867041249938530657'\n      item: TimelineTweet,\n    }[], // Comments to the tweets are also tweets\n    displayType: 'VerticalConversation',\n  };\n};\n\ntype TimelineTweet = {\n  __typename: 'TimelineTweet';\n  tweet_results: {\n    result: Tweet;\n  };\n};\n\ntype Tweet = {\n  __typename: 'Tweet';\n  core: {\n    user_results: {\n      result: User;\n    };\n  };\n  views: {\n    count: string; // '13763'\n  };\n  legacy: {\n    bookmark_count: number; // 358\n    created_at: string; // 'Tue Dec 10 17:41:28 +0000 2024'\n    conversation_id_str: string; // '1867041249938530657'\n    display_text_range: number[]; // [0, 58]\n    favorite_count: number; // 151\n    full_text: string; //  \"How I'd promote my startup, if I had 0 followers (Part 1)\"\n    lang: string; // 'en'\n    quote_count: number;\n    reply_count: number;\n    retweet_count: number;\n    user_id_str: string; // '1867041249938530657'\n    id_str: string; // '1867041249938530657'\n    entities: {\n      media: Media[];\n      hashtags: Hashtag[];\n      urls: Url[];\n      user_mentions: UserMention[];\n    };\n  };\n};\n\ntype User = {\n  __typename: 'User';\n  id: string; // 'VXNlcjoxNDUxM4ADSG44MTA4NDc4OTc2'\n  rest_id: string; // '1867041249938530657'\n  is_blue_verified: boolean;\n  profile_image_shape: 'Circle'; // ...\n  legacy: {\n    following: boolean;\n    created_at: string; // 'Thu Oct 21 09:30:37 +0000 2021'\n    description: string; // 'I help startup founders double their MRR with outside-the-box marketing cheat sheets'\n    favourites_count: number; // 22195\n    followers_count: number; // 25658\n    friends_count: number;\n    location: string; // 'San Francisco'\n    media_count: number;\n    name: string; //  'John Doe'\n    profile_banner_url: string; // 'https://pbs.twimg.com/profile_banners/4863509452891265813/4863509'\n    profile_image_url_https: string; // 'https://pbs.twimg.com/profile_images/4863509452891265813/4863509_normal.jpg'\n    screen_name: string; // 'johndoe'\n    url: string; // 'https://t.co/dgTEddFGDd'\n    verified: boolean;\n  };\n};\n\ntype Media = {\n  display_url: string; // 'pic.x.com/X7823zS3sNU'\n  expanded_url: string; // 'https://x.com/johndoe/status/1867041249938530657/video/1'\n  ext_alt_text: string; // 'Image of two bridges.'\n  id_str: string; // '1867041249938530657'\n  indices: number[]; // [93, 116]\n  media_key: string; // '13_2866509231399826944'\n  media_url_https: string; // 'https://pbs.twimg.com/profile_images/1867041249938530657/4863509_normal.jpg'\n  source_status_id_str: string; // '1867041249938530657'\n  source_user_id_str: string; // '1867041249938530657'\n  type: string; // 'video'\n  url: string; // 'https://t.co/X78dBgtrsNU'\n  features: {\n    large: { faces: FaceGeometry[] };\n    medium: { faces: FaceGeometry[] };\n    small: { faces: FaceGeometry[] };\n    orig: { faces: FaceGeometry[] };\n  };\n  sizes: {\n    large: MediaSize;\n    medium: MediaSize;\n    small: MediaSize;\n    thumb: MediaSize;\n  };\n  video_info: VideoInfo[];\n};\n\ntype UserMention = {\n  id_str: string; // '98008038'\n  name: string; // 'Yann LeCun'\n  screen_name: string; // 'ylecun'\n  indices: number[]; // [115, 122]\n};\n\ntype Hashtag = {\n  indices: number[]; // [257, 263]\n  text: string;\n};\n\ntype Url = {\n  display_url: string; // 'google.com'\n  expanded_url: string; // 'http://google.com'\n  url: string; // 'https://t.co/nZh3aF0Aw6'\n  indices: number[]; // [102, 125]\n};\n\ntype VideoInfo = {\n  aspect_ratio: number[]; // [427, 240]\n  duration_millis: number; // 20000\n  variants: {\n    bitrate?: number; // 288000\n    content_type?: string; // 'application/x-mpegURL' | 'video/mp4' | ...\n    url: string; // 'https://video.twimg.com/amplify_video/18665094345456w6944/pl/-ItQau_LRWedR-W7.m3u8?tag=14'\n  };\n};\n\ntype FaceGeometry = { x: number; y: number; h: number; w: number };\n\ntype MediaSize = { h: number; w: number; resize: 'fit' | 'crop' };\n\ntype ActionKey = string;\n```\n","fields":{"slug":"/blog/2024/api-design-x-home-timeline/"},"internal":{"contentFilePath":"/home/runner/work/trekhleb.github.io/trekhleb.github.io/src/posts/2024/api-design-x-home-timeline/index.mdx"},"frontmatter":{"title":"API Design of X (Twitter) Home Timeline","summary":"An exploration of how X's home timeline API is designed","date":"12 December, 2024","cover":{"childImageSharp":{"gatsbyImageData":{"layout":"fullWidth","backgroundColor":"#080808","images":{"fallback":{"src":"/static/6c3fe261d3b0a2dfbaa7d2e03447f6d6/f5b5d/01-cover.png","srcSet":"/static/6c3fe261d3b0a2dfbaa7d2e03447f6d6/b0daf/01-cover.png 750w,\n/static/6c3fe261d3b0a2dfbaa7d2e03447f6d6/fed9b/01-cover.png 1080w,\n/static/6c3fe261d3b0a2dfbaa7d2e03447f6d6/41cc5/01-cover.png 1366w,\n/static/6c3fe261d3b0a2dfbaa7d2e03447f6d6/f5b5d/01-cover.png 1920w","sizes":"100vw"},"sources":[{"srcSet":"/static/6c3fe261d3b0a2dfbaa7d2e03447f6d6/9f1fe/01-cover.webp 750w,\n/static/6c3fe261d3b0a2dfbaa7d2e03447f6d6/3902f/01-cover.webp 1080w,\n/static/6c3fe261d3b0a2dfbaa7d2e03447f6d6/5bbcb/01-cover.webp 1366w,\n/static/6c3fe261d3b0a2dfbaa7d2e03447f6d6/1d24e/01-cover.webp 1920w","type":"image/webp","sizes":"100vw"}]},"width":1,"height":0.4088541666666667}}}}}},"pageContext":{"slug":"/blog/2024/api-design-x-home-timeline/","frontmatter":{"title":"API Design of X (Twitter) Home Timeline","summary":"An exploration of how X's home timeline API is designed","cover":"assets/01-cover.png","date":"2024-12-12T00:00:00.000Z"}}},"staticQueryHashes":[],"slicesMap":{}}