{"componentChunkName":"component---src-templates-post-tsx-content-file-path-src-posts-2020-printed-links-detection-index-md","path":"/blog/2020/printed-links-detection/","result":{"data":{"mdx":{"id":"cb56b835-4e5c-5cde-812f-fb9f8cea3170","body":"\n![Links Detector Cover](assets/27.png)\n\n## 📃 TL;DR\n\n_In this article we will start solving the issue of making the printed links (i.e. in a book or in a magazine) clickable via your smartphone camera._\n\nWe will use [TensorFlow 2 Object Detection API](https://github.com/tensorflow/models/tree/master/research/object_detection) to train a custom object detector model to find positions and bounding boxes of the sub-strings like `https://` in the text image (i.e. in smartphone camera stream).\n\nThe text of each link (right continuation of `https://` bounding box) will be recognized by using [Tesseract](https://tesseract.projectnaptha.com/) library. The recognition part will not be covered in this article, but you may find the complete code example of the application in [links-detector repository](https://github.com/trekhleb/links-detector).\n\n> 🚀 [Launch Links Detector demo](https://trekhleb.dev/links-detector/) from your smartphone to see the final result.\n\n> 📝 [Open links-detector repository](https://github.com/trekhleb/links-detector) on GitHub to see the complete source code of the application.\n\nHere is how the final solution will look like:\n\n![Links Detector Demo](assets/02-demo.gif)\n\n> ⚠️ Currently the application is in _experimental_ _Alpha_ stage and has [many issues and limitations](https://github.com/trekhleb/links-detector/issues?q=is%3Aopen+is%3Aissue+label%3Aenhancement). So don't raise your expectations level too high until these issues are resolved 🤷🏻‍. Also, the purpose of this article is more about learning how to work with TensorFlow 2 Object Detection API rather than coming up with a production-ready model.\n\n> In case if Python code blocks in this article will lack proper formatting on this platform feel free to [to read the article on GitHub](https://github.com/trekhleb/links-detector/blob/master/articles/printed_links_detection/printed_links_detection.md)\n\n## 🤷🏻‍️ The Problem\n\nI work as a software engineer and in my own time, I learn Machine Learning as a hobby. But this is not the problem yet.\n\nI bought a printed book about Machine Learning recently and while I was reading through the first several chapters I've encountered many printed links in the text that looked like `https://tensorflow.org/` or `https://some-url.com/which/may/be/even/longer?and_with_params=true`.\n\n![Printed Links](assets/0.jpg)\n\nI saw all these links, but I couldn't click on them since they were printed (thanks, cap!). To visit these links I needed to start typing them character by character in the browser's address bar, which was pretty annoying and error-prone.\n\n## 💡 Possible Solution\n\nSo, I was thinking, what if, similarly to QR-code detection, we will try to \"teach\" the smartphone to _(1)_ _detect_ and _(2)_ _recognize_ printed links for us and to make them _clickable_? This way you would do just one click instead of multiple keystrokes. The operational complexity of \"clicking\" the printed links goes from `O(N)` to `O(1)`.\n\nThis is how the final workflow will look like:\n\n![Links Detector Demo](assets/1.gif)\n\n## 📝 Solution Requirements\n\nAs I've mentioned earlier I'm just studying Machine Learning as a hobby. Thus, the purpose of this article is more about _learning_ how to work with TensorFlow 2 Object Detection API rather than coming up with a production-ready application.\n\nWith that being said, I simplified the solution requirements to the following:\n\n1. The detection and recognition processes should have a **close-to-real-time** performance (i.e. `0.5-1` frames per second) on a device like iPhone X. It means that the whole _detection + recognition_ process should take up to `2` seconds (pretty bearable as for the amateur project).\n2. Only **English** links should be supported.\n3. Only **dark text** (i.e. black or dark-grey) on **light background** (i.e. white or light-grey) should be supported.\n4. Only `https://` links should be supported for now (it is ok if our model will not recognize the `http://`, `ftp://`, `tcp://` or other types of links).\n\n## 🧩 Solution Breakdown\n\n### High-level breakdown\n\nLet's see how we could approach the problem on a high level.\n\n#### Option 1: Detection model on the back-end\n\n**The flow:**\n\n1. Get camera stream (frame by frame) on the client-side.\n2. Send each frame one by one over the network to the back-end.\n3. Do link detection and recognition on the back-end and send the response back to the client.\n4. Client draws the detection boxes with the clickable links.\n\n![Model on the back-end](assets/2.jpg)\n\n**Pros:**\n\n- 💚 The detection performance is not limited by the client's device. We may speed the detection up by scaling the service horizontally (adding more instances) and vertically (adding more cores/GPUs).\n- 💚 The model might be bigger since there is no need to upload it to the client-side. Downloading the `~10Mb` model on the client-side may be ok, but loading the `~100Mb` model might be a big issue for the client's network and application UX (user experience) otherwise.\n- 💚 It is possible to control who is using the model. Model is guarded behind the API, so we would have complete control over its callers/clients.\n\n**Cons:**\n\n- 💔 System complexity growth. The application tech stack grew from just `JavaScript` to, let's say, `JavaScript + Python`. We need to take care of the autoscaling.\n- 💔 Offline mode for the app is not possible since it needs an internet connection to work.\n- 💔 Too many HTTP requests between the client and the server may become a bottleneck at some point. Imagine if we would want to improve the performance of the detection, let's say, from `1` to `10+` frames per second. This means that each client will send `10+` requests per second. For `10` simultaneous clients it is already `100+` requests per second. The `HTTP/2` bidirectional streaming and `gRPC` might be useful in this case, but we're going back to the increased system complexity here.\n- 💔 System becomes more expensive. Almost all points from the Pros section need to be paid for.\n\n#### Option 2: Detection model on the front-end\n\n**The flow:**\n\n1. Get camera stream (frame by frame) on the client-side.\n2. Do link detection and recognition on the client-side (without sending anything to the back-end).\n3. Client draws the detection boxes with the clickable links.\n\n![Model on the front-end](assets/3.jpg)\n\n**Pros:**\n\n- 💚 System is less complex. We don't need to set up the servers, build the API, and introduce an additional Python stack to the system.\n- 💚 Offline mode is possible. The app doesn't need an internet connection to work since the model is fully loaded to the device. So the Progressive Web Application ([PWA](https://web.dev/progressive-web-apps/)) might be built to support that.\n- 💚 System is \"kind of\" scaling automatically. The more clients you have, the more cores and GPUs they bring. This is not a proper scaling solution though (more about that in a Cons section below).\n- 💚 System is cheaper. We only need a server for static assets (`HTML`, `JS`, `CSS`, model files, etc.). This may be done for free, let's say, on GitHub.\n- 💚 No issue with the growing number of HTTP requests per second to the server-side.\n\n**Cons:**\n\n- 💔 Only horizontal scaling is possible (each client will have its own CPU/GPU). Vertical scaling is not possible since we can't influence the client's device performance. As a result, we can't guarantee fast detection for low performant devices.\n- 💔 It is not possible to guard the model usage and control the callers/clients of the model. Everyone could download the model and re-use it.\n- 💔 Battery consumption of the client's device might become an issue. For the model to work it needs computational resources. So clients might not be happy with their iPhone getting warmer and warmer while the app is working.\n\n#### High-level conclusion\n\nSince the purpose of the project was more about learning and not coming up with a production-ready solution _I decided to go with the second option of serving the model from the client side_. This made the whole project much cheaper (actually with GitHub it was free to host it), and I could focus more on Machine Learning than on the autoscaling back-end infrastructure.\n\n### Lower level breakdown\n\nOk, so we've decided to go with the serverless solution. Now we have an image from the camera stream as an input that looks something like this:\n\n![Printed Links Input](assets/4.jpg)\n\nWe need to solve two sub-tasks for this image:\n\n1. Links **detection** (finding the position and bounding boxes of the links)\n2. Links **recognition** (recognizing the text of the links)\n\n#### Option 1: Tesseract based solution\n\nThe first and the most obvious approach would be to solve the _Optical Character Recognition_ ([OCR](https://en.wikipedia.org/wiki/Optical_character_recognition)) task by recognizing the whole text of the image by using, let's say, [Tesseract.js](https://github.com/naptha/tesseract.js) library. It returns the bounding boxes of the paragraphs, text lines, and text blocks along with the recognized text.\n\n![Recognized text with bounding boxes](assets/5.jpg)\n\nWe may try then to extract the links from the recognized text lines or text blocks with a regular expression like [this one](https://stackoverflow.com/questions/3809401/what-is-a-good-regular-expression-to-match-a-url) (example is on TypeScript):\n\n```typescript\nconst URL_REG_EXP = /https?:\\/\\/(www\\.)?[-a-zA-Z0-9@:%._+~#=]{2,256}\\.[a-z]{2,4}\\b([-a-zA-Z0-9@:%_+.~#?&/=]*)/gi;\n\nconst extractLinkFromText = (text: string): string | null => {\n  const urls: string[] | null = text.match(URL_REG_EXP);\n  if (!urls || !urls.length) {\n    return null;\n  }\n  return urls[0];\n};\n```\n\n💚 Seems like the issue is solved in a pretty straightforward and simple way:\n\n- We know the bounding boxes of the links\n- We also know the text of the links to make them clickable\n\n💔 The thing is that the _recognition + detection_ time may vary from `2` to `20+` seconds depending on the size of the text, on the amount of \"something that looks like a text\" on the image, on the image quality and on other factors. So it will be really hard to achieve those `0.5-1` frames per second to make the user experience at least _close_ to real-time.\n\n💔 Also if we would think about it, we're asking the library to recognize the **whole** text from the image for us even though it might contain only one or two links in it (i.e. only ~10% of the text might be useful for us), or it may even not contain the links at all. In this case, it sounds like a waste of computational resources.\n\n#### Option 2: Tesseract + TensorFlow based solution\n\nWe could make Tesseract work faster if we used some _additional \"adviser\" algorithm_ prior to the links text recognition. This \"adviser\" algorithm should detect, but not recognize, _the leftmost position_ of each link on the image if there are any. This will allow us to speed up the recognition part by following these rules:\n\n1. If the image does not contain any link we should not call Tesseract detection/recognition at all.\n2. If the image does have the links then we need to ask Tesseract to recognize only those parts of the image that contains the links. We're not interested in spending the time for recognition of the irrelevant text that does not contain the links.\n\nThe \"adviser\" algorithm that will take place before the Tesseract should work with a constant time regardless of the image quality, or the presence/absence of the text on the image. It also should be pretty fast and detect the leftmost positions of the links for less than `1s` so that we could satisfy the \"close-to-real-time\" requirement (i.e. on iPhone X).\n\n> 💡 So what if we will use another object detection model to help us find all occurrences of the `https://` substrings (every secure link has this prefix, doesn't it) in the image? Then, having these `https://` bounding boxes in the text we may extract the right-side continuation of them and send them to the Tesseract for text recognition.\n\nTake a look at the picture below:\n\n![Tesseract and TensorFlow based solution](assets/6.jpg)\n\nYou may notice that Tesseract needs to do **much less** work in case if it would have some hints about where are the links might be located (see the number of blue boxes on both pictures).\n\nSo the question now is which object detection model we should choose and how to re-train it to support the detection of the custom `https://` objects.\n\n> Finally! We've got closer to the TensorFlow part of the article 😀\n\n## 🤖 Selecting the Object Detection Model\n\nTraining a new object detection model is not a reasonable option in our context because of the following reasons:\n\n- 💔 The training process might take days/weeks and bucks.\n- 💔 We most probably won't be able to collect hundreds of thousands of _labeled_ images of the books that have links in them (we might try to generate them though, but more about that later).\n\nSo instead of creating a new model, we should better teach an existing object detection model to do the custom object detection for us (to do the [transfer learning](https://en.wikipedia.org/wiki/Transfer_learning)). In our case, the \"custom objects\" would be the images with `https://` text drawn in them. This approach has the following benefits:\n\n- 💚 The dataset might be much smaller. We don't need to collect hundreds of thousands of the labeled images. Instead, we may do `~100` pictures and label them manually. This is because the model is already pre-trained on the general dataset like [COCO dataset](https://cocodataset.org/#home) and already learned how to extract general image features.\n- 💚 The training process will be much faster (minutes/hours on GPU instead of days/weeks). Again, this is because of a smaller dataset (smaller batches) and because of fewer trainable parameters.\n\nWe may choose the existing model from [TensorFlow 2 Detection Model Zoo](https://github.com/tensorflow/models/blob/master/research/object_detection/g3doc/tf2_detection_zoo.md) which provides a collection of detection models pre-trained on the [COCO 2017 dataset](https://cocodataset.org/#home). Now it contains `~40` model variations to choose from.\n\nTo re-train and fine-tune the model on the custom dataset we will use a [TensorFlow 2 Object Detection API](https://github.com/tensorflow/models/tree/master/research/object_detection). The TensorFlow Object Detection API is an open-source framework built on top of [TensorFlow](https://www.tensorflow.org/) that makes it easy to construct, train, and deploy object detection models.\n\nIf you follow the [Model Zoo](https://github.com/tensorflow/models/blob/master/research/object_detection/g3doc/tf2_detection_zoo.md) link you will find the _detection speed_ and _accuracy_ for each model.\n\n![Model Zoo](assets/7.jpg)\n\n*Image source: [TensorFlow Model Zoo](https://github.com/tensorflow/models/blob/master/research/object_detection/g3doc/tf2_detection_zoo.md) repository*\n\nOf course, we would want to find the right balance between the detection **speed** and **accuracy** while picking the model. But what might be even more important in our case is the **size** of the model since it will be loaded to the client-side.\n\nThe size of the archived model might vary drastically from `~20Mb` to `~1Gb`. Here are several examples:\n\n- `1386 (Mb)` `centernet_hg104_1024x1024_kpts_coco17_tpu-32`\n- ` 330 (Mb)` `centernet_resnet101_v1_fpn_512x512_coco17_tpu-8`\n- ` 195 (Mb)` `centernet_resnet50_v1_fpn_512x512_coco17_tpu-8`\n- ` 198 (Mb)` `centernet_resnet50_v1_fpn_512x512_kpts_coco17_tpu-8`\n- ` 227 (Mb)` `centernet_resnet50_v2_512x512_coco17_tpu-8`\n- ` 230 (Mb)` `centernet_resnet50_v2_512x512_kpts_coco17_tpu-8`\n- `  29 (Mb)` `efficientdet_d0_coco17_tpu-32`\n- `  49 (Mb)` `efficientdet_d1_coco17_tpu-32`\n- `  60 (Mb)` `efficientdet_d2_coco17_tpu-32`\n- `  89 (Mb)` `efficientdet_d3_coco17_tpu-32`\n- ` 151 (Mb)` `efficientdet_d4_coco17_tpu-32`\n- ` 244 (Mb)` `efficientdet_d5_coco17_tpu-32`\n- ` 376 (Mb)` `efficientdet_d6_coco17_tpu-32`\n- ` 376 (Mb)` `efficientdet_d7_coco17_tpu-32`\n- ` 665 (Mb)` `extremenet`\n- ` 427 (Mb)` `faster_rcnn_inception_resnet_v2_1024x1024_coco17_tpu-8`\n- ` 424 (Mb)` `faster_rcnn_inception_resnet_v2_640x640_coco17_tpu-8`\n- ` 337 (Mb)` `faster_rcnn_resnet101_v1_1024x1024_coco17_tpu-8`\n- ` 337 (Mb)` `faster_rcnn_resnet101_v1_640x640_coco17_tpu-8`\n- ` 343 (Mb)` `faster_rcnn_resnet101_v1_800x1333_coco17_gpu-8`\n- ` 449 (Mb)` `faster_rcnn_resnet152_v1_1024x1024_coco17_tpu-8`\n- ` 449 (Mb)` `faster_rcnn_resnet152_v1_640x640_coco17_tpu-8`\n- ` 454 (Mb)` `faster_rcnn_resnet152_v1_800x1333_coco17_gpu-8`\n- ` 202 (Mb)` `faster_rcnn_resnet50_v1_1024x1024_coco17_tpu-8`\n- ` 202 (Mb)` `faster_rcnn_resnet50_v1_640x640_coco17_tpu-8`\n- ` 207 (Mb)` `faster_rcnn_resnet50_v1_800x1333_coco17_gpu-8`\n- ` 462 (Mb)` `mask_rcnn_inception_resnet_v2_1024x1024_coco17_gpu-8`\n- `  86 (Mb)` `ssd_mobilenet_v1_fpn_640x640_coco17_tpu-8`\n- `  44 (Mb)` `ssd_mobilenet_v2_320x320_coco17_tpu-8`\n- `  20 (Mb)` `ssd_mobilenet_v2_fpnlite_320x320_coco17_tpu-8`\n- `  20 (Mb)` `ssd_mobilenet_v2_fpnlite_640x640_coco17_tpu-8`\n- ` 369 (Mb)` `ssd_resnet101_v1_fpn_1024x1024_coco17_tpu-8`\n- ` 369 (Mb)` `ssd_resnet101_v1_fpn_640x640_coco17_tpu-8`\n- ` 481 (Mb)` `ssd_resnet152_v1_fpn_1024x1024_coco17_tpu-8`\n- ` 480 (Mb)` `ssd_resnet152_v1_fpn_640x640_coco17_tpu-8`\n- ` 233 (Mb)` `ssd_resnet50_v1_fpn_1024x1024_coco17_tpu-8`\n- ` 233 (Mb)` `ssd_resnet50_v1_fpn_640x640_coco17_tpu-8`\n\nThe **`ssd_mobilenet_v2_fpnlite_640x640_coco17_tpu-8`** model might be a good fit in our case:\n\n- 💚 It is relatively lightweight: `20Mb` archived.\n- 💚 It is pretty fast: `39ms` for the detection.\n- 💚 It uses the MobileNet v2 network as a feature extractor which is optimized for usage on mobile devices to reduce energy consumption.\n- 💚 It does the object detection for the whole image and for all objects in it **in one go** regardless of the image content (no [regions proposal](https://en.wikipedia.org/wiki/Region_Based_Convolutional_Neural_Networks) step is involved which makes the detection faster).\n- 💔 It is not the most accurate model though (everything is a tradeoff ⚖️).\n\nThe model name encodes some several important characteristics that you may read more about if you want:\n\n- The expected image input size is `640x640px`.\n- The model implements [Single Shot MultiBox Detector](https://arxiv.org/abs/1512.02325) (SSD) and [Feature Pyramid Network](https://arxiv.org/abs/1612.03144) (FPN).\n- [MobileNet v2](https://ai.googleblog.com/2018/04/mobilenetv2-next-generation-of-on.html) convolutional neural network ([CNN](https://en.wikipedia.org/wiki/Convolutional_neural_network)) is used as a feature extractor.\n- The model was trained on [COCO dataset](https://cocodataset.org/#home)\n\n## 🛠 Installing Object Detection API\n\nIn this article, we're going to install the Tensorflow 2 Object Detection API _as a Python package_. It is convenient in case if you're experimenting in [Google Colab](https://colab.research.google.com/) (recommended) or in [Jupyter](https://jupyter.org/try). For both cases no local installation is needed, you may experiment right in your browser.\n\nYou may also follow the [official documentation](https://github.com/tensorflow/models/blob/master/research/object_detection/g3doc/tf2.md) if you would prefer to install Object Detection API via Docker.\n\n> If you stuck with something during the API installation or during the dataset preparation try to read through the [TensorFlow 2 Object Detection API tutorial](https://tensorflow-object-detection-api-tutorial.readthedocs.io/en/latest/index.html) which adds a lot of useful details to this process.\n\nFirst, let's clone the [API repository](https://github.com/tensorflow/models):\n\n```bash\ngit clone --depth 1 https://github.com/tensorflow/models\n```\n\n_output →_\n\n```\nCloning into 'models'...\nremote: Enumerating objects: 2301, done.\nremote: Counting objects: 100% (2301/2301), done.\nremote: Compressing objects: 100% (2000/2000), done.\nremote: Total 2301 (delta 561), reused 922 (delta 278), pack-reused 0\nReceiving objects: 100% (2301/2301), 30.60 MiB | 13.90 MiB/s, done.\nResolving deltas: 100% (561/561), done.\n```\n\nNow, let's compile the [API proto files](https://github.com/tensorflow/models/tree/master/research/object_detection/protos) into Python files by using [protoc](https://grpc.io/docs/protoc-installation/) tool:\n\n```bash\ncd ./models/research\nprotoc object_detection/protos/*.proto --python_out=.\n```\n\nFinally, let's install the TF2 version of [setup.py](https://github.com/tensorflow/models/blob/master/research/object_detection/packages/tf2/setup.py) via `pip`:\n\n```bash\ncp ./object_detection/packages/tf2/setup.py .\npip install . --quiet\n```\n\n> It is possible that the last step will fail because of some dependency errors. In this case, you might want to run `pip install . --quiet` one more time.\n\nWe may test that installation went successfully by running the following tests:\n\n```bash\npython object_detection/builders/model_builder_tf2_test.py\n```\n\nYou should see the logs that end with something similar to this:\n\n```\n[       OK ] ModelBuilderTF2Test.test_unknown_ssd_feature_extractor\n----------------------------------------------------------------------\nRan 20 tests in 45.072s\n\nOK (skipped=1)\n```\n\nThe TensorFlow Object Detection API is installed! You may now use the scripts that API provides for doing the model [inference](https://github.com/tensorflow/models/blob/master/research/object_detection/colab_tutorials/inference_tf2_colab.ipynb), [training](https://github.com/tensorflow/models/blob/master/research/object_detection/g3doc/tf2_training_and_evaluation.md) or [fine-tuning](https://github.com/tensorflow/models/blob/master/research/object_detection/colab_tutorials/eager_few_shot_od_training_tf2_colab.ipynb).\n\n## ⬇️ Downloading the Pre-Trained Model\n\nLet's download our selected `ssd_mobilenet_v2_fpnlite_640x640_coco17_tpu-8` model from the TensorFlow Model Zoo and check how it does the general object detection (detection of the objects of classes from COCO dataset like \"cat\", \"dog\", \"car\", etc.).\n\nWe will use the [get_file()](https://www.tensorflow.org/api_docs/python/tf/keras/utils/get_file) TensorFlow helper to download the archived model from the URL and unpack it.\n\n```python\nimport tensorflow as tf\nimport pathlib\n\nMODEL_NAME = 'ssd_mobilenet_v2_fpnlite_640x640_coco17_tpu-8'\nTF_MODELS_BASE_PATH = 'http://download.tensorflow.org/models/object_detection/tf2/20200711/'\nCACHE_FOLDER = './cache'\n\ndef download_tf_model(model_name, cache_folder):\n    model_url = TF_MODELS_BASE_PATH + model_name + '.tar.gz'\n    model_dir = tf.keras.utils.get_file(\n        fname=model_name,\n        origin=model_url,\n        untar=True,\n        cache_dir=pathlib.Path(cache_folder).absolute()\n    )\n    return model_dir\n\n# Start the model download.\nmodel_dir = download_tf_model(MODEL_NAME, CACHE_FOLDER)\nprint(model_dir)\n```\n\n_output →_\n\n```\n/content/cache/datasets/ssd_mobilenet_v2_fpnlite_640x640_coco17_tpu-8\n```\n\nHere is how the folder structure looks so far:\n\n![Cache Folder](assets/8.jpg)\n\nThe `checkpoint` folder contains the snapshot of the pre-trained model.\n\nThe `pipeline.config` file contains the detection settings of the model. We'll come back to this file later when we will need to fine-tune the model.\n\n## 🏄🏻‍️ Trying the Model (Doing the Inference)\n\nFor now, the model can detect the object of [90 COCO dataset classes](https://cocodataset.org/#explore) like a `car`, `bird`, `hot dog` etc.\n\n![COCO classes](assets/9.jpg)\n\n*Image source: [COCO dataset](https://cocodataset.org/#explore) website*\n\nLet's see how the model performs on some general images that contain the objects of these classes.\n\n### Loading COCO labels\n\nObject Detection API already has a complete set of COCO labels (classes) defined for us.\n\n```python\nimport os\n\n# Import Object Detection API helpers.\nfrom object_detection.utils import label_map_util\n\n# Loads the COCO labels data (class names and indices relations).\ndef load_coco_labels():\n    # Object Detection API already has a complete set of COCO classes defined for us.\n    label_map_path = os.path.join(\n        'models/research/object_detection/data',\n        'mscoco_complete_label_map.pbtxt'\n    )\n    label_map = label_map_util.load_labelmap(label_map_path)\n\n    # Class ID to Class Name mapping.\n    categories = label_map_util.convert_label_map_to_categories(\n        label_map,\n        max_num_classes=label_map_util.get_max_label_map_index(label_map),\n        use_display_name=True\n    )\n    category_index = label_map_util.create_category_index(categories)\n\n    # Class Name to Class ID mapping.\n    label_map_dict = label_map_util.get_label_map_dict(label_map, use_display_name=True)\n\n    return category_index, label_map_dict\n\n# Load COCO labels.\ncoco_category_index, coco_label_map_dict = load_coco_labels()\n\nprint('coco_category_index:', coco_category_index)\nprint('coco_label_map_dict:', coco_label_map_dict)\n```\n\n_output →_\n\n```\ncoco_category_index:\n{\n    1: {'id': 1, 'name': 'person'},\n    2: {'id': 2, 'name': 'bicycle'},\n    ...\n    90: {'id': 90, 'name': 'toothbrush'},\n}\n\ncoco_label_map_dict:\n{\n    'background': 0,\n    'person': 1,\n    'bicycle': 2,\n    'car': 3,\n    ...\n    'toothbrush': 90,\n}\n```\n\n### Build a detection function\n\nWe need to create a detection function that will use the pre-trained model we've downloaded to do the object detection.\n\n```python\nimport tensorflow as tf\n\n# Import Object Detection API helpers.\nfrom object_detection.utils import config_util\nfrom object_detection.builders import model_builder\n\n# Generates the detection function for specific model and specific model's checkpoint\ndef detection_fn_from_checkpoint(config_path, checkpoint_path):\n    # Build the model.\n    pipeline_config = config_util.get_configs_from_pipeline_file(config_path)\n    model_config = pipeline_config['model']\n    model = model_builder.build(\n        model_config=model_config,\n        is_training=False,\n    )\n\n    # Restore checkpoints.\n    ckpt = tf.compat.v2.train.Checkpoint(model=model)\n    ckpt.restore(checkpoint_path).expect_partial()\n\n    # This is a function that will do the detection.\n    @tf.function\n    def detect_fn(image):\n        image, shapes = model.preprocess(image)\n        prediction_dict = model.predict(image, shapes)\n        detections = model.postprocess(prediction_dict, shapes)\n\n        return detections, prediction_dict, tf.reshape(shapes, [-1])\n\n    return detect_fn\n\ninference_detect_fn = detection_fn_from_checkpoint(\n    config_path=os.path.join('cache', 'datasets', MODEL_NAME, 'pipeline.config'),\n    checkpoint_path=os.path.join('cache', 'datasets', MODEL_NAME, 'checkpoint', 'ckpt-0'),\n)\n```\n\nThis `inference_detect_fn` function will accept an image and will return the detected objects' info.\n\n### Loading the images for inference\n\nLet's try to detect the object on this image:\n\n![General Object Inference](assets/10.jpg)\n\n*Image source: [oleksii_trekhleb](https://www.instagram.com/oleksii_trekhleb/?hl=en) Instagram*\n\nTo do that let's save the image to the `inference/test/` folder of our project. If you're using Google Colab you may create this folder and upload the image manually.\n\nHere is how the folder structure looks so far:\n\n![Folder structure](assets/11.jpg)\n\n```python\nimport matplotlib.pyplot as plt\n%matplotlib inline\n\n# Creating a TensorFlow dataset of just one image.\ninference_ds = tf.keras.preprocessing.image_dataset_from_directory(\n  directory='inference',\n  image_size=(640, 640),\n  batch_size=1,\n  shuffle=False,\n  label_mode=None\n)\n# Numpy version of the dataset.\ninference_ds_numpy = list(inference_ds.as_numpy_iterator())\n\n# You may preview the images in dataset like this.\nplt.figure(figsize=(14, 14))\nfor i, image in enumerate(inference_ds_numpy):\n    plt.subplot(2, 2, i + 1)\n    plt.imshow(image[0].astype(\"uint8\"))\n    plt.axis(\"off\")\nplt.show()\n```\n\n### Running the detection on test data\n\nNow we're ready to run the detection. The `inference_ds_numpy[0]` array stores the pixel data for the first image in `Numpy` format.\n\n```python\ndetections, predictions_dict, shapes = inference_detect_fn(\n    inference_ds_numpy[0]\n)\n```\n\nLet's see the shapes of the output:\n\n```python\nboxes = detections['detection_boxes'].numpy()\nscores = detections['detection_scores'].numpy()\nclasses = detections['detection_classes'].numpy()\nnum_detections = detections['num_detections'].numpy()[0]\n\nprint('boxes.shape: ', boxes.shape)\nprint('scores.shape: ', scores.shape)\nprint('classes.shape: ', classes.shape)\nprint('num_detections:', num_detections)\n```\n\n_output →_\n\n```\nboxes.shape:  (1, 100, 4)\nscores.shape:  (1, 100)\nclasses.shape:  (1, 100)\nnum_detections: 100.0\n```\n\nThe model has made a `100` detections for us. It doesn't mean that it found `100` objects on the image though. It means that the model has `100` slots, and it can detect `100` objects at max on a single image. Each detection has a score that represents the confidence of the model about it. The bounding boxes for each detection are stored in the `boxes` array. The scores or confidences of the model about each detection are stored in the `scores` array. Finally, the `classes` array stores the labels (classes) for each detection.\n\nLet's check the first 5 detections:\n\n```python\nprint('First 5 boxes:')\nprint(boxes[0,:5])\n\nprint('First 5 scores:')\nprint(scores[0,:5])\n\nprint('First 5 classes:')\nprint(classes[0,:5])\n\nclass_names = [coco_category_index[idx + 1]['name'] for idx in classes[0]]\nprint('First 5 class names:')\nprint(class_names[:5])\n```\n\n_output →_\n\n```\nFirst 5 boxes:\n[[0.17576033 0.84654826 0.25642633 0.88327974]\n [0.5187813  0.12410264 0.6344235  0.34545377]\n [0.5220358  0.5181462  0.6329132  0.7669856 ]\n [0.50933677 0.7045719  0.5619138  0.7446198 ]\n [0.44761637 0.51942706 0.61237675 0.75963426]]\n\nFirst 5 scores:\n[0.6950246 0.6343004 0.591157  0.5827219 0.5415643]\n\nFirst 5 classes:\n[9. 8. 8. 0. 8.]\n\nFirst 5 class names:\n['traffic light', 'boat', 'boat', 'person', 'boat']\n```\n\nThe model sees the `traffic light`, three `boats`, and a `person` on the image. We may confirm that indeed these objects are seen on the image.\n\nFrom the `scores` array may see that the model is most confident (close to 70% of probability) in the `traffic light` object.\n\nEach entry of `boxes` array is `[y1, x1, y2, x2]`, where `(x1, y1)` and `(x2, y2)` are the top-left and bottom-right corners of the bounding box.\n\nLet's visualize the detection boxes:\n\n```python\n# Importing Object Detection API helpers.\nfrom object_detection.utils import visualization_utils\n\n# Visualizes the bounding boxes on top of the image.\ndef visualize_detections(image_np, detections, category_index):\n    label_id_offset = 1\n    image_np_with_detections = image_np.copy()\n\n    visualization_utils.visualize_boxes_and_labels_on_image_array(\n        image_np_with_detections,\n        detections['detection_boxes'][0].numpy(),\n        (detections['detection_classes'][0].numpy() + label_id_offset).astype(int),\n        detections['detection_scores'][0].numpy(),\n        category_index,\n        use_normalized_coordinates=True,\n        max_boxes_to_draw=200,\n        min_score_thresh=.4,\n        agnostic_mode=False,\n    )\n\n    plt.figure(figsize=(12, 16))\n    plt.imshow(image_np_with_detections)\n    plt.show()\n\n# Visualizing the detections.\nvisualize_detections(\n    image_np=tf.cast(inference_ds_numpy[0][0], dtype=tf.uint32).numpy(),\n    detections=detections,\n    category_index=coco_category_index,\n)\n```\n\nHere is the output:\n\n![Inference result](assets/12.jpg)\n\nIf we will do the detection for the text image here is what we will see:\n\n![Inference result for text image](assets/13.jpg)\n\nThe model couldn't detect anything on this image. This is what we're going to change, we want to teach the model to \"see\" the `https://` prefixes on this image.\n\n## 📝 Preparing the Custom Dataset\n\nTo \"teach\" the `ssd_mobilenet_v2_fpnlite_640x640_coco17_tpu-8` model to detect the custom objects which are _not_ a part of a COCO dataset we need to do the fine-tune training on a new custom dataset.\n\nThe datasets for object detection consist of two parts:\n\n1. The image itself (i.e. the image of the book page)\n2. The boundary boxes that show where exactly on the image the custom objects are located.\n\n![Bounding Boxes](assets/14.jpg)\n\nIn the example above each box has `left-top` and `right-bottom` coordinates in _absolute_ values (in pixels). However, there are also different formats of writing the location of the bounding boxes exists. For example, we may locate the bounding box by setting the coordinate of its `center point` and its `width` and `height`. We might also use _relative_ values (percentage of the width and height of the image) for setting up the coordinates. But you've got the idea, the network needs to know what the image is and where on the image the objects are located.\n\nNow, how can we get the custom dataset for training? We have three options here:\n\n1. _Re-use_ the existing dataset.\n2. _Generate_ a new dataset of fake book images.\n3. _Create_ the dataset manually by taking or downloading the pictures of real book pages which contain `https://` links and labeling all bounding boxes.\n\n### Option 1: Re-using the existing dataset\n\nThere are plenty of the datasets that are shared to be re-used by researches. We could start from the following resources to find a proper dataset:\n\n- [Google Dataset Search](https://datasetsearch.research.google.com/)\n- [Kaggle Datasets](https://www.kaggle.com/datasets)\n- [awesome-public-datasets](https://github.com/awesomedata/awesome-public-datasets) repository\n- etc.\n\n💚 If you could find the needed dataset and its license allows you to re-use it, it is probably the fastest way to get straight to the model training.\n\n💔 I couldn't find the dataset with labeled `https://` prefixes though.\n\nSo we need to skip this option.\n\n### Option 2: Generating the synthetic dataset\n\nThere are tools that exist (i.e. [keras_ocr](https://keras-ocr.readthedocs.io/en/latest/examples/end_to_end_training.html#generating-synthetic-data)) that might help us to generate random text, include the link in it, and draw it on images with some background and distortions.\n\n💚 The cool part about this approach is that we have the freedom to generate training examples for different _fonts_, _ligatures_, _text colors_, _background colors_. This is very useful if we want to avoid the [model overfitting](https://en.wikipedia.org/wiki/Overfitting) during the training (so that the model could generalize well to unseen real-world examples instead of failing once the background shade is changed for a bit).\n\n💚 It is also possible to generate a variety of link types like `http://`, `http://`, `ftp://`, `tcp://` etc. Otherwise, it might be hard to find enough real-world examples of this kind of links for training.\n\n💚 Another benefit of this approach is that we could generate as many training examples as we want. We're not limited to the number of pages of the printed book we've found for the dataset. Increasing the number of training examples may also increase the accuracy of the model.\n\n💔 It is possible though to misuse the generator and to generate the training images that will be quite different from real-world examples. Let's say we may use the wrong and unrealistic distortions for the page (i.e. using waves bend instead of the arc one). In this case, the model will not generalize well to real-world examples.\n\n> I see this approach as a really promising one. It may help to overcome many model issues (more on that below). I didn't try it yet though. But it might be a good candidate for another article.\n\n### Option 3: Creating the dataset manually\n\nThe most straightforward way though is to get the book (or books) and to make the pictures of the pages with the links and to label all of them manually.\n\nThe good news is that the dataset might be pretty small (hundreds of images might be enough) because we're not going to train the model _from scratch_ but instead, we're going to do a [transfer learning](https://en.wikipedia.org/wiki/Transfer_learning) (also see the [few-shot learning](https://paperswithcode.com/task/few-shot-learning).)\n\n💚 In this case, the training dataset will be really close to real-world data. You will literally take the printed book, take a picture of it with realistic fonts, bends, shades, perspectives, and colors.\n\n💔 Even though it doesn't require a lot of images it may still be time-consuming.\n\n💔 It is hard to come up with a diverse database where training examples would have different fonts, background colors, and different types of links (we need to find many diverse books and magazines to accomplish that).\n\nSince the article has a learning purpose and since we're not trying to win an object detection competition let's go with this option for now and try to create a dataset by ourselves.\n\n### Preprocessing the data\n\nSo, I've ended up shooting `125` images of the book pages that contain one or more `https://` links on them.\n\n![Raw Dataset](assets/15.jpg)\n\nI put all these images in the `dataset/printed_links/raw` folder.\n\nNext, I'm going to preprocess the images by doing the following:\n\n- **Resize** each image to the width of `1024px` (they are too big originally and have a width of `3024px`)\n- **Crop** each image to make them squared (this is optional, and we could just resize the image by simply squeezing it, but I want the model to be trained on realistic proportions of `https:` boxes).\n- **Rotate** image if needed by applying the [exif](https://en.wikipedia.org/wiki/Exif) metadata.\n- **Greyscale** the image (we don't need the model to take the colors into consideration).\n- **Increase brightness**\n- **Increase contrast**\n- **Increase sharpness**\n\nRemember, that once we've decided to apply these transformations and adjustments to the dataset we need to do the same in the future for each image that we will send to the model for detection.\n\nHere is how we could apply these adjustments to the image using Python:\n\n```python\nimport os\nimport math\nimport shutil\n\nfrom pathlib import Path\nfrom PIL import Image, ImageOps, ImageEnhance\n\n# Resize an image.\ndef preprocess_resize(target_width):\n    def preprocess(image: Image.Image, log) -> Image.Image:\n        (width, height) = image.size\n        ratio = width / height\n\n        if width > target_width:\n            target_height = math.floor(target_width / ratio)\n            log(f'Resizing: To size {target_width}x{target_height}')\n            image = image.resize((target_width, target_height))\n        else:\n            log('Resizing: Image already resized, skipping...')\n\n        return image\n    return preprocess\n\n# Crop an image.\ndef preprocess_crop_square():\n    def preprocess(image: Image.Image, log) -> Image.Image:\n        (width, height) = image.size\n\n        left = 0\n        top = 0\n        right = width\n        bottom = height\n\n        crop_size = min(width, height)\n\n        if width >= height:\n            # Horizontal image.\n            log(f'Squre cropping: Horizontal {crop_size}x{crop_size}')\n            left = width // 2 - crop_size // 2\n            right = left + crop_size\n        else:\n            # Vetyical image.\n            log(f'Squre cropping: Vertical {crop_size}x{crop_size}')\n            top = height // 2 - crop_size // 2\n            bottom = top + crop_size\n\n        image = image.crop((left, top, right, bottom))\n        return image\n    return preprocess\n\n# Apply exif transpose to an image.\ndef preprocess_exif_transpose():\n    # @see: https://pillow.readthedocs.io/en/stable/reference/ImageOps.html\n    def preprocess(image: Image.Image, log) -> Image.Image:\n        log('EXif transpose')\n        image = ImageOps.exif_transpose(image)\n        return image\n    return preprocess\n\n# Apply color transformations to the image.\ndef preprocess_color(brightness, contrast, color, sharpness):\n    # @see: https://pillow.readthedocs.io/en/3.0.x/reference/ImageEnhance.html\n    def preprocess(image: Image.Image, log) -> Image.Image:\n        log('Coloring')\n\n        enhancer = ImageEnhance.Color(image)\n        image = enhancer.enhance(color)\n\n        enhancer = ImageEnhance.Brightness(image)\n        image = enhancer.enhance(brightness)\n\n        enhancer = ImageEnhance.Contrast(image)\n        image = enhancer.enhance(contrast)\n\n        enhancer = ImageEnhance.Sharpness(image)\n        image = enhancer.enhance(sharpness)\n\n        return image\n    return preprocess\n\n# Image pre-processing pipeline.\ndef preprocess_pipeline(src_dir, dest_dir, preprocessors=[], files_num_limit=0, override=False):\n    # Create destination folder if not exists.\n    Path(dest_dir).mkdir(parents=False, exist_ok=True)\n\n    # Get the list of files to be copied.\n    src_file_names = os.listdir(src_dir)\n    files_total = files_num_limit if files_num_limit > 0 else len(src_file_names)\n    files_processed = 0\n\n    # Logger function.\n    def preprocessor_log(message):\n        print('  ' + message)\n\n    # Iterate through files.\n    for src_file_index, src_file_name in enumerate(src_file_names):\n        if files_num_limit > 0 and src_file_index >= files_num_limit:\n            break\n\n        # Copy file.\n        src_file_path = os.path.join(src_dir, src_file_name)\n        dest_file_path = os.path.join(dest_dir, src_file_name)\n\n        progress = math.floor(100 * (src_file_index + 1) / files_total)\n        print(f'Image {src_file_index + 1}/{files_total} | {progress}% |  {src_file_path}')\n\n        if not os.path.isfile(src_file_path):\n            preprocessor_log('Source is not a file, skipping...\\n')\n            continue\n\n        if not override and os.path.exists(dest_file_path):\n            preprocessor_log('File already exists, skipping...\\n')\n            continue\n\n        shutil.copy(src_file_path, dest_file_path)\n        files_processed += 1\n\n        # Preprocess file.\n        image = Image.open(dest_file_path)\n\n        for preprocessor in preprocessors:\n            image = preprocessor(image, preprocessor_log)\n\n        image.save(dest_file_path, quality=95)\n        print('')\n\n    print(f'{files_processed} out of {files_total} files have been processed')\n\n# Launching the image preprocessing pipeline.\npreprocess_pipeline(\n    src_dir='dataset/printed_links/raw',\n    dest_dir='dataset/printed_links/processed',\n    override=True,\n    # files_num_limit=1,\n    preprocessors=[\n        preprocess_exif_transpose(),\n        preprocess_resize(target_width=1024),\n        preprocess_crop_square(),\n        preprocess_color(brightness=2, contrast=1.3, color=0, sharpness=1),\n    ]\n)\n```\n\nAs a result, all processed images were saved to the `dataset/printed_links/processed` folder.\n\n![Dataset Processed](assets/16.jpg)\n\nYou may preview the images like this:\n\n```python\nimport matplotlib.pyplot as plt\nimport numpy as np\n\ndef preview_images(images_dir, images_num=1, figsize=(15, 15)):\n    image_names = os.listdir(images_dir)\n    image_names = image_names[:images_num]\n\n    num_cells = math.ceil(math.sqrt(images_num))\n    figure = plt.figure(figsize=figsize)\n\n    for image_index, image_name in enumerate(image_names):\n        image_path = os.path.join(images_dir, image_name)\n        image = Image.open(image_path)\n\n        figure.add_subplot(num_cells, num_cells, image_index + 1)\n        plt.imshow(np.asarray(image))\n\n    plt.show()\n\npreview_images('dataset/printed_links/processed', images_num=4, figsize=(16, 16))\n```\n\n### Labeling the dataset\n\nTo do the labeling (to mark the locations of the objects that we're interested in, namely the `https://` prefixes) we may use the [LabelImg](https://github.com/tzutalin/labelImg) graphical image annotation tool.\n\n> For this step you might want to install the LabelImg tool on your local machine (not in Colab). You may find the detailed installation instructions in [LabelImg README](https://github.com/tzutalin/labelImg).\n\nOnce you have LabelImg tool installed you may launch it for the `dataset/printed_links/processed` folder from the root of your project like this:\n\n```bash\nlabelImg dataset/printed_links/processed\n```\n\nThen you'll need to label all the images from the `dataset/printed_links/processed` folder and save annotations as XML files to `dataset/printed_links/labels/xml/` folder.\n\n![Labeling](assets/17.jpg)\n\n![Labeling Process](assets/18.gif)\n\nAfter the labeling we should have an XML file with bounding boxes data for each image:\n\n![Labels folder structure](assets/19.jpg)\n\n### Splitting the dataset into train, test, and validation subsets\n\nTo identify the model's [overfitting or underfitting](https://en.wikipedia.org/wiki/Overfitting) issue we need to split the dataset into `train` and `test` dataset. Let's say `80%` of our images will be used to train the model and `20%` of the images will be used to check how well the model generalizes to the images that it didn't see before.\n\n> In this section we'll do the files splitting by copying them into different folders (`test` and `train` folders). However, this might not be the most optimal way. Instead, the splitting of the dataset may be done on [tf.data.Dataset](https://www.tensorflow.org/api_docs/python/tf/data/Dataset) level.\n\n```python\nimport re\nimport random\n\ndef partition_dataset(\n    images_dir,\n    xml_labels_dir,\n    train_dir,\n    test_dir,\n    val_dir,\n    train_ratio,\n    test_ratio,\n    val_ratio,\n    copy_xml\n):\n    if not os.path.exists(train_dir):\n        os.makedirs(train_dir)\n\n    if not os.path.exists(test_dir):\n        os.makedirs(test_dir)\n\n    if not os.path.exists(val_dir):\n        os.makedirs(val_dir)\n\n    images = [f for f in os.listdir(images_dir)\n              if re.search(r'([a-zA-Z0-9\\s_\\\\.\\-\\(\\):])+(.jpg|.jpeg|.png)$', f, re.IGNORECASE)]\n\n    num_images = len(images)\n\n    num_train_images = math.ceil(train_ratio * num_images)\n    num_test_images = math.ceil(test_ratio * num_images)\n    num_val_images = math.ceil(val_ratio * num_images)\n\n    print('Intended split')\n    print(f'  train: {num_train_images}/{num_images} images')\n    print(f'  test: {num_test_images}/{num_images} images')\n    print(f'  val: {num_val_images}/{num_images} images')\n\n    actual_num_train_images = 0\n    actual_num_test_images = 0\n    actual_num_val_images = 0\n\n    def copy_random_images(num_images, dest_dir):\n        copied_num = 0\n\n        if not num_images:\n            return copied_num\n\n        for i in range(num_images):\n            if not len(images):\n                break\n\n            idx = random.randint(0, len(images)-1)\n            filename = images[idx]\n            shutil.copyfile(os.path.join(images_dir, filename), os.path.join(dest_dir, filename))\n\n            if copy_xml:\n                xml_filename = os.path.splitext(filename)[0]+'.xml'\n                shutil.copyfile(os.path.join(xml_labels_dir, xml_filename), os.path.join(dest_dir, xml_filename))\n\n            images.remove(images[idx])\n            copied_num += 1\n\n        return copied_num\n\n    actual_num_train_images = copy_random_images(num_train_images, train_dir)\n    actual_num_test_images = copy_random_images(num_test_images, test_dir)\n    actual_num_val_images = copy_random_images(num_val_images, val_dir)\n\n    print('\\n', 'Actual split')\n    print(f'  train: {actual_num_train_images}/{num_images} images')\n    print(f'  test: {actual_num_test_images}/{num_images} images')\n    print(f'  val: {actual_num_val_images}/{num_images} images')\n\npartition_dataset(\n    images_dir='dataset/printed_links/processed',\n    train_dir='dataset/printed_links/partitioned/train',\n    test_dir='dataset/printed_links/partitioned/test',\n    val_dir='dataset/printed_links/partitioned/val',\n    xml_labels_dir='dataset/printed_links/labels/xml',\n    train_ratio=0.8,\n    test_ratio=0.2,\n    val_ratio=0,\n    copy_xml=True\n)\n```\n\nAfter splitting your dataset folder structure should look similar to this:\n\n```\ndataset/\n└── printed_links\n    ├── labels\n    │   └── xml\n    ├── partitioned\n    │   ├── test\n    │   └── train\n    │       ├── IMG_9140.JPG\n    │       ├── IMG_9140.xml\n    │       ├── IMG_9141.JPG\n    │       ├── IMG_9141.xml\n    │       ...\n    ├── processed\n    └── raw\n```\n\n### Exporting the dataset\n\nThe last manipulation we should do with the data is to convert our datasets into [TFRecord](https://www.tensorflow.org/tutorials/load_data/tfrecord) format. The `TFRecord` format is a format that TensorFlow is using for storing a sequence of binary records.\n\nFirst, let's create two folders: one is for the labels in `CSV` format, and the other one is for the final dataset in `TFRecord` format.\n\n```bash\nmkdir -p dataset/printed_links/labels/csv\nmkdir -p dataset/printed_links/tfrecords\n```\n\nNow we need to create a `dataset/printed_links/labels/label_map.pbtxt` proto file that will describe the classes of the objects in our dataset. In our case, we only have _one class_ which we may call `http`. Here is the content of this file:\n\n```\nitem {\n  id: 1\n  name: 'http'\n}\n```\n\nNow we're ready to generate the TFRecord datasets out of images in `jpg` format and labels in `xml` format:\n\n```python\nimport os\nimport io\nimport math\nimport glob\nimport tensorflow as tf\nimport pandas as pd\nimport xml.etree.ElementTree as ET\nfrom PIL import Image\nfrom collections import namedtuple\nfrom object_detection.utils import dataset_util, label_map_util\n\ntf1 = tf.compat.v1\n\n# Convers labels from XML format to CSV.\ndef xml_to_csv(path):\n    xml_list = []\n    for xml_file in glob.glob(path + '/*.xml'):\n        tree = ET.parse(xml_file)\n        root = tree.getroot()\n        for member in root.findall('object'):\n            value = (root.find('filename').text,\n                int(root.find('size')[0].text),\n                int(root.find('size')[1].text),\n                member[0].text,\n                int(member[4][0].text),\n                int(member[4][1].text),\n                int(member[4][2].text),\n                int(member[4][3].text)\n            )\n            xml_list.append(value)\n    column_name = ['filename', 'width', 'height', 'class', 'xmin', 'ymin', 'xmax', 'ymax']\n    xml_df = pd.DataFrame(xml_list, columns=column_name)\n    return xml_df\n\n\ndef class_text_to_int(row_label, label_map_dict):\n    return label_map_dict[row_label]\n\n\ndef split(df, group):\n    data = namedtuple('data', ['filename', 'object'])\n    gb = df.groupby(group)\n    return [data(filename, gb.get_group(x)) for filename, x in zip(gb.groups.keys(), gb.groups)]\n\n\n# Creates a TFRecord.\ndef create_tf_example(group, path, label_map_dict):\n    with tf1.gfile.GFile(os.path.join(path, '{}'.format(group.filename)), 'rb') as fid:\n        encoded_jpg = fid.read()\n\n    encoded_jpg_io = io.BytesIO(encoded_jpg)\n    image = Image.open(encoded_jpg_io)\n    width, height = image.size\n\n    filename = group.filename.encode('utf8')\n    image_format = b'jpg'\n    xmins = []\n    xmaxs = []\n    ymins = []\n    ymaxs = []\n    classes_text = []\n    classes = []\n\n    for index, row in group.object.iterrows():\n        xmins.append(row['xmin'] / width)\n        xmaxs.append(row['xmax'] / width)\n        ymins.append(row['ymin'] / height)\n        ymaxs.append(row['ymax'] / height)\n        classes_text.append(row['class'].encode('utf8'))\n        classes.append(class_text_to_int(row['class'], label_map_dict))\n\n    tf_example = tf1.train.Example(features=tf1.train.Features(feature={\n        'image/height': dataset_util.int64_feature(height),\n        'image/width': dataset_util.int64_feature(width),\n        'image/filename': dataset_util.bytes_feature(filename),\n        'image/source_id': dataset_util.bytes_feature(filename),\n        'image/encoded': dataset_util.bytes_feature(encoded_jpg),\n        'image/format': dataset_util.bytes_feature(image_format),\n        'image/object/bbox/xmin': dataset_util.float_list_feature(xmins),\n        'image/object/bbox/xmax': dataset_util.float_list_feature(xmaxs),\n        'image/object/bbox/ymin': dataset_util.float_list_feature(ymins),\n        'image/object/bbox/ymax': dataset_util.float_list_feature(ymaxs),\n        'image/object/class/text': dataset_util.bytes_list_feature(classes_text),\n        'image/object/class/label': dataset_util.int64_list_feature(classes),\n    }))\n\n    return tf_example\n\n\ndef dataset_to_tfrecord(\n    images_dir,\n    xmls_dir,\n    label_map_path,\n    output_path,\n    csv_path=None\n):\n    label_map = label_map_util.load_labelmap(label_map_path)\n    label_map_dict = label_map_util.get_label_map_dict(label_map)\n\n    tfrecord_writer = tf1.python_io.TFRecordWriter(output_path)\n    images_path = os.path.join(images_dir)\n    csv_examples = xml_to_csv(xmls_dir)\n    grouped_examples = split(csv_examples, 'filename')\n\n    for group in grouped_examples:\n        tf_example = create_tf_example(group, images_path, label_map_dict)\n        tfrecord_writer.write(tf_example.SerializeToString())\n\n    tfrecord_writer.close()\n\n    print('Successfully created the TFRecord file: {}'.format(output_path))\n\n    if csv_path is not None:\n        csv_examples.to_csv(csv_path, index=None)\n        print('Successfully created the CSV file: {}'.format(csv_path))\n\n# Generate a TFRecord for train dataset.\ndataset_to_tfrecord(\n    images_dir='dataset/printed_links/partitioned/train',\n    xmls_dir='dataset/printed_links/partitioned/train',\n    label_map_path='dataset/printed_links/labels/label_map.pbtxt',\n    output_path='dataset/printed_links/tfrecords/train.record',\n    csv_path='dataset/printed_links/labels/csv/train.csv'\n)\n\n# Generate a TFRecord for test dataset.\ndataset_to_tfrecord(\n    images_dir='dataset/printed_links/partitioned/test',\n    xmls_dir='dataset/printed_links/partitioned/test',\n    label_map_path='dataset/printed_links/labels/label_map.pbtxt',\n    output_path='dataset/printed_links/tfrecords/test.record',\n    csv_path='dataset/printed_links/labels/csv/test.csv'\n)\n```\n\nAs a result we should now have two files: `test.record` and `train.record` in `dataset/printed_links/tfrecords/` folder:\n\n```\ndataset/\n└── printed_links\n    ├── labels\n    │   ├── csv\n    │   ├── label_map.pbtxt\n    │   └── xml\n    ├── partitioned\n    │   ├── test\n    │   ├── train\n    │   └── val\n    ├── processed\n    ├── raw\n    └── tfrecords\n        ├── test.record\n        └── train.record\n```\n\nThese two files `test.record` and `train.record` are our final datasets that we will use to fine-tune the `ssd_mobilenet_v2_fpnlite_640x640_coco17_tpu-8` model.\n\n## 📖 Exploring the TFRecord Datasets\n\nIn this section, we will see how we may use the TensorFlow 2 Object Detection API to explore the datasets in `TFRecord` format.\n\n**Checking the number of items in a dataset**\n\nTo count the number of items in the dataset we may do the following:\n\n```python\nimport tensorflow as tf\n\n# Count the number of examples in the dataset.\ndef count_tfrecords(tfrecords_filename):\n    raw_dataset = tf.data.TFRecordDataset(tfrecords_filename)\n    # Keep in mind that the list() operation might be\n    # a performance bottleneck for large datasets.\n    return len(list(raw_dataset))\n\nTRAIN_RECORDS_NUM = count_tfrecords('dataset/printed_links/tfrecords/train.record')\nTEST_RECORDS_NUM = count_tfrecords('dataset/printed_links/tfrecords/test.record')\n\nprint('TRAIN_RECORDS_NUM: ', TRAIN_RECORDS_NUM)\nprint('TEST_RECORDS_NUM:  ', TEST_RECORDS_NUM)\n```\n\n_output →_\n\n```\nTRAIN_RECORDS_NUM:  100\nTEST_RECORDS_NUM:   25\n```\n\nSo we will train the model on `100` examples, and we will check the model accuracy on `25` test images.\n\n**Previewing the dataset images with bounding boxes**\n\nTo preview images with detection boxes we may do the following:\n\n```python\nimport tensorflow as tf\nimport numpy as np\nfrom google.protobuf import text_format\nimport matplotlib.pyplot as plt\n\n# Import Object Detection API.\nfrom object_detection.utils import visualization_utils\nfrom object_detection.protos import string_int_label_map_pb2\nfrom object_detection.data_decoders.tf_example_decoder import TfExampleDecoder\n\n%matplotlib inline\n\n# Visualize the TFRecord dataset.\ndef visualize_tfrecords(tfrecords_filename, label_map=None, print_num=1):\n    decoder = TfExampleDecoder(\n        label_map_proto_file=label_map,\n        use_display_name=False\n    )\n\n    if label_map is not None:\n        label_map_proto = string_int_label_map_pb2.StringIntLabelMap()\n\n        with tf.io.gfile.GFile(label_map,'r') as f:\n            text_format.Merge(f.read(), label_map_proto)\n            class_dict = {}\n\n            for entry in label_map_proto.item:\n                class_dict[entry.id] = {'name': entry.name}\n\n    raw_dataset = tf.data.TFRecordDataset(tfrecords_filename)\n\n    for raw_record in raw_dataset.take(print_num):\n        example = decoder.decode(raw_record)\n\n        image = example['image'].numpy()\n        boxes = example['groundtruth_boxes'].numpy()\n        confidences = example['groundtruth_image_confidences']\n        filename = example['filename']\n        area = example['groundtruth_area']\n        classes = example['groundtruth_classes'].numpy()\n        image_classes = example['groundtruth_image_classes']\n        weights = example['groundtruth_weights']\n\n        scores = np.ones(boxes.shape[0])\n\n        visualization_utils.visualize_boxes_and_labels_on_image_array(\n            image,\n            boxes,\n            classes,\n            scores,\n            class_dict,\n            max_boxes_to_draw=None,\n            use_normalized_coordinates=True\n        )\n\n        plt.figure(figsize=(8, 8))\n        plt.imshow(image)\n\n    plt.show()\n\n# Visualizing the training TFRecord dataset.\nvisualize_tfrecords(\n    tfrecords_filename='dataset/printed_links/tfrecords/train.record',\n    label_map='dataset/printed_links/labels/label_map.pbtxt',\n    print_num=3\n)\n```\n\nAs a result, we should see several images with bounding boxes drawn on top of each image.\n\n![TFRecord Preview](assets/20.jpg)\n\n## 📈 Setting Up TensorBoard\n\nBefore starting the training process we need to launch a [TensorBoard](https://www.tensorflow.org/tensorboard).\n\nTensorBoard will allow us to monitor the training process and see if the model is actually learning something or should we better stop the training and adjust training parameters. It will also help us to analyze what objects and at what location the model is detecting.\n\n![TensorBoard](assets/21.gif)\n\n*Image source: [TensorBoard homepage](https://www.tensorflow.org/tensorboard)*\n\nThe cool part about TensorBoard is that we may run it directly in Google Colab. However, if you're running the notebook in your local installation of Jupyter you may also [install it as Python package](https://github.com/tensorflow/tensorboard/blob/master/README.md) and launch it from the terminal.\n\nFirst, let's create a `./logs` folder where all training logs will be written:\n\n```bash\nmkdir -p logs\n```\n\nNext, we may load the TensorBoard extension on Google Colab:\n\n```\n%load_ext tensorboard\n```\n\nAnd finally we may launch a TensorBoard to monitor the `./logs` folder:\n\n```\n%tensorboard --logdir ./logs\n```\n\nAs a result, you should see the empty TensorBoard panel:\n\n![Empty TensorBoard Panel](assets/22.jpg)\n\nAfter the model training is be started you may get back to this panel and see the training process progress.\n\n## 🏋🏻‍️ Model Training\n\n### Configuring the Detection Pipeline\n\nNow it's time to get back to the `cache/datasets/ssd_mobilenet_v2_fpnlite_640x640_coco17_tpu-8/pipeline.config` file that we've mentioned earlier. This file defines the parameters of `ssd_mobilenet_v2_fpnlite_640x640_coco17_tpu-8` model training.\n\nWe need to copy the `pipeline.config` file to the root of the project and adjust a couple of things in it:\n\n1. We should change the **number of classes** from `90` (the COCO classes) to just `1` (the `http` class).\n2. We should reduce the **batch size** to `8` to avoid the errors that are connected to the insufficient memory.\n3. We need to point the model to its **checkpoints** since we don't want to train the model from scratch.\n4. We need to change the `fine_tune_checkpoint_type` to `detection`.\n5. We need to point the model to a proper **labels map**.\n6. Lastly, we need to pint the model to the **train and test datasets**.\n\nAll these changes may be done manually directly in `pipeline.config` file. But we may also do them through code:\n\n```python\nimport tensorflow as tf\nfrom shutil import copyfile\nfrom google.protobuf import text_format\nfrom object_detection.protos import pipeline_pb2\n\n# Adjust pipeline config modification here if needed.\ndef modify_config(pipeline):\n    # Model config.\n    pipeline.model.ssd.num_classes = 1\n\n    # Train config.\n    pipeline.train_config.batch_size = 8\n\n    pipeline.train_config.fine_tune_checkpoint = 'cache/datasets/ssd_mobilenet_v2_fpnlite_640x640_coco17_tpu-8/checkpoint/ckpt-0'\n    pipeline.train_config.fine_tune_checkpoint_type = 'detection'\n\n    # Train input reader config.\n    pipeline.train_input_reader.label_map_path = 'dataset/printed_links/labels/label_map.pbtxt'\n    pipeline.train_input_reader.tf_record_input_reader.input_path[0] = 'dataset/printed_links/tfrecords/train.record'\n\n    # Eval input reader config.\n    pipeline.eval_input_reader[0].label_map_path = 'dataset/printed_links/labels/label_map.pbtxt'\n    pipeline.eval_input_reader[0].tf_record_input_reader.input_path[0] = 'dataset/printed_links/tfrecords/test.record'\n\n    return pipeline\n\ndef clone_pipeline_config():\n    copyfile(\n        'cache/datasets/ssd_mobilenet_v2_fpnlite_640x640_coco17_tpu-8/pipeline.config',\n        'pipeline.config'\n    )\n\ndef setup_pipeline(pipeline_config_path):\n    clone_pipeline_config()\n    pipeline = read_pipeline_config(pipeline_config_path)\n    pipeline = modify_config(pipeline)\n    write_pipeline_config(pipeline_config_path, pipeline)\n    return pipeline\n\ndef read_pipeline_config(pipeline_config_path):\n    pipeline = pipeline_pb2.TrainEvalPipelineConfig()\n    with tf.io.gfile.GFile(pipeline_config_path, \"r\") as f:\n        proto_str = f.read()\n        text_format.Merge(proto_str, pipeline)\n    return pipeline\n\ndef write_pipeline_config(pipeline_config_path, pipeline):\n    config_text = text_format.MessageToString(pipeline)\n    with tf.io.gfile.GFile(pipeline_config_path, \"wb\") as f:\n        f.write(config_text)\n\n# Adjusting the pipeline configuration.\npipeline = setup_pipeline('pipeline.config')\n\nprint(pipeline)\n```\n\nHere is the content of the `pipeline.config` file:\n\n```\nmodel {\n  ssd {\n    num_classes: 1\n    image_resizer {\n      fixed_shape_resizer {\n        height: 640\n        width: 640\n      }\n    }\n    feature_extractor {\n      type: \"ssd_mobilenet_v2_fpn_keras\"\n      depth_multiplier: 1.0\n      min_depth: 16\n      conv_hyperparams {\n        regularizer {\n          l2_regularizer {\n            weight: 3.9999998989515007e-05\n          }\n        }\n        initializer {\n          random_normal_initializer {\n            mean: 0.0\n            stddev: 0.009999999776482582\n          }\n        }\n        activation: RELU_6\n        batch_norm {\n          decay: 0.996999979019165\n          scale: true\n          epsilon: 0.0010000000474974513\n        }\n      }\n      use_depthwise: true\n      override_base_feature_extractor_hyperparams: true\n      fpn {\n        min_level: 3\n        max_level: 7\n        additional_layer_depth: 128\n      }\n    }\n    box_coder {\n      faster_rcnn_box_coder {\n        y_scale: 10.0\n        x_scale: 10.0\n        height_scale: 5.0\n        width_scale: 5.0\n      }\n    }\n    matcher {\n      argmax_matcher {\n        matched_threshold: 0.5\n        unmatched_threshold: 0.5\n        ignore_thresholds: false\n        negatives_lower_than_unmatched: true\n        force_match_for_each_row: true\n        use_matmul_gather: true\n      }\n    }\n    similarity_calculator {\n      iou_similarity {\n      }\n    }\n    box_predictor {\n      weight_shared_convolutional_box_predictor {\n        conv_hyperparams {\n          regularizer {\n            l2_regularizer {\n              weight: 3.9999998989515007e-05\n            }\n          }\n          initializer {\n            random_normal_initializer {\n              mean: 0.0\n              stddev: 0.009999999776482582\n            }\n          }\n          activation: RELU_6\n          batch_norm {\n            decay: 0.996999979019165\n            scale: true\n            epsilon: 0.0010000000474974513\n          }\n        }\n        depth: 128\n        num_layers_before_predictor: 4\n        kernel_size: 3\n        class_prediction_bias_init: -4.599999904632568\n        share_prediction_tower: true\n        use_depthwise: true\n      }\n    }\n    anchor_generator {\n      multiscale_anchor_generator {\n        min_level: 3\n        max_level: 7\n        anchor_scale: 4.0\n        aspect_ratios: 1.0\n        aspect_ratios: 2.0\n        aspect_ratios: 0.5\n        scales_per_octave: 2\n      }\n    }\n    post_processing {\n      batch_non_max_suppression {\n        score_threshold: 9.99999993922529e-09\n        iou_threshold: 0.6000000238418579\n        max_detections_per_class: 100\n        max_total_detections: 100\n        use_static_shapes: false\n      }\n      score_converter: SIGMOID\n    }\n    normalize_loss_by_num_matches: true\n    loss {\n      localization_loss {\n        weighted_smooth_l1 {\n        }\n      }\n      classification_loss {\n        weighted_sigmoid_focal {\n          gamma: 2.0\n          alpha: 0.25\n        }\n      }\n      classification_weight: 1.0\n      localization_weight: 1.0\n    }\n    encode_background_as_zeros: true\n    normalize_loc_loss_by_codesize: true\n    inplace_batchnorm_update: true\n    freeze_batchnorm: false\n  }\n}\ntrain_config {\n  batch_size: 8\n  data_augmentation_options {\n    random_horizontal_flip {\n    }\n  }\n  data_augmentation_options {\n    random_crop_image {\n      min_object_covered: 0.0\n      min_aspect_ratio: 0.75\n      max_aspect_ratio: 3.0\n      min_area: 0.75\n      max_area: 1.0\n      overlap_thresh: 0.0\n    }\n  }\n  sync_replicas: true\n  optimizer {\n    momentum_optimizer {\n      learning_rate {\n        cosine_decay_learning_rate {\n          learning_rate_base: 0.07999999821186066\n          total_steps: 50000\n          warmup_learning_rate: 0.026666000485420227\n          warmup_steps: 1000\n        }\n      }\n      momentum_optimizer_value: 0.8999999761581421\n    }\n    use_moving_average: false\n  }\n  fine_tune_checkpoint: \"cache/datasets/ssd_mobilenet_v2_fpnlite_640x640_coco17_tpu-8/checkpoint/ckpt-0\"\n  num_steps: 50000\n  startup_delay_steps: 0.0\n  replicas_to_aggregate: 8\n  max_number_of_boxes: 100\n  unpad_groundtruth_tensors: false\n  fine_tune_checkpoint_type: \"detection\"\n  fine_tune_checkpoint_version: V2\n}\ntrain_input_reader {\n  label_map_path: \"dataset/printed_links/labels/label_map.pbtxt\"\n  tf_record_input_reader {\n    input_path: \"dataset/printed_links/tfrecords/train.record\"\n  }\n}\neval_config {\n  metrics_set: \"coco_detection_metrics\"\n  use_moving_averages: false\n}\neval_input_reader {\n  label_map_path: \"dataset/printed_links/labels/label_map.pbtxt\"\n  shuffle: false\n  num_epochs: 1\n  tf_record_input_reader {\n    input_path: \"dataset/printed_links/tfrecords/test.record\"\n  }\n}\n```\n\n### Launching the training process\n\nWe're ready now to launch a training process using the TensorFlow 2 Object Detection API. The API contains a [model_main_tf2.py](https://github.com/tensorflow/models/blob/master/research/object_detection/model_main_tf2.py) script that will run training for us. Feel free to explore the flags that this Python script supports in the source-code (i.e. `num_train_steps`, `model_dir` and others) to see their meanings.\n\nWe will be training the model for `1000` iterations (epochs). Feel free to train it for a smaller or larger number of iterations depending on the learning progress (see the TensorBoard charts).\n\n```bash\n%%bash\n\nNUM_TRAIN_STEPS=1000\nCHECKPOINT_EVERY_N=1000\n\nPIPELINE_CONFIG_PATH=pipeline.config\nMODEL_DIR=./logs\nSAMPLE_1_OF_N_EVAL_EXAMPLES=1\n\npython ./models/research/object_detection/model_main_tf2.py \\\n  --model_dir=$MODEL_DIR \\\n  --num_train_steps=$NUM_TRAIN_STEPS \\\n  --sample_1_of_n_eval_examples=$SAMPLE_1_OF_N_EVAL_EXAMPLES \\\n  --pipeline_config_path=$PIPELINE_CONFIG_PATH \\\n  --checkpoint_every_n=$CHECKPOINT_EVERY_N \\\n  --alsologtostderr\n```\n\nWhile the model is training (it may take around`~10 minutes` for `1000` iterations in [GoogleColab GPU](https://colab.research.google.com/notebooks/gpu.ipynb) runtime) you should be able to observe the training progress in TensorBoard. The `localization` and `classification` losses should decrease which means that the model is doing a good job in localizing and classifying new custom objects.\n\n![Training Process](assets/23.jpg)\n\nAlso during the training, the new model checkpoints (parameters that the model has learned during the training) will be saved to the `logs` folder.\n\nThe `logs` folder structure now looks like this:\n\n```\nlogs\n├── checkpoint\n├── ckpt-1.data-00000-of-00001\n├── ckpt-1.index\n└── train\n    └── events.out.tfevents.1606560330.b314c371fa10.1747.1628.v2\n```\n\n### Evaluating the Model (Optional)\n\nThe evaluation process uses the trained model checkpoints and evaluates how well the model performs in detecting objects in the test dataset. The results of this evaluation are summarised in the form of some [metrics](https://github.com/tensorflow/models/blob/master/research/object_detection/g3doc/evaluation_protocols.md), which can be examined over time. You may read more about how to evaluate these metrics [here](https://tensorflow-object-detection-api-tutorial.readthedocs.io/en/latest/training.html#evaluating-the-model-optional).\n\nWe will skip the metrics evaluation step in this article. But we may still use the evaluation step to see the model's detections in TensorBoard:\n\n```bash\n%%bash\n\nPIPELINE_CONFIG_PATH=pipeline.config\nMODEL_DIR=logs\n\npython ./models/research/object_detection/model_main_tf2.py \\\n  --model_dir=$MODEL_DIR \\\n  --pipeline_config_path=$PIPELINE_CONFIG_PATH \\\n  --checkpoint_dir=$MODEL_DIR \\\n```\n\nAfter launching the script you should be able to see several side-by-side images with detections boxes:\n\n![Model Evaluation](assets/24.jpg)\n\n## 🗜 Exporting the Model\n\nOnce the training process is complete we should save the trained model for further usage. To export the model we will use the [exporter_main_v2.py](https://github.com/tensorflow/models/blob/master/research/object_detection/exporter_main_v2.py) script from Object Detection API. It prepares an object detection TensorFlow graph for inference using model configuration and a trained checkpoint. The script outputs associated checkpoint files, a SavedModel, and a copy of the model config:\n\n```bash\n%%bash\n\npython ./models/research/object_detection/exporter_main_v2.py \\\n    --input_type=image_tensor \\\n    --pipeline_config_path=pipeline.config \\\n    --trained_checkpoint_dir=logs \\\n    --output_directory=exported/ssd_mobilenet_v2_fpnlite_640x640_coco17_tpu-8\n```\n\nHere is what the `exported` folder contains after the export:\n\n```\nexported\n└── ssd_mobilenet_v2_fpnlite_640x640_coco17_tpu-8\n    ├── checkpoint\n    │   ├── checkpoint\n    │   ├── ckpt-0.data-00000-of-00001\n    │   └── ckpt-0.index\n    ├── pipeline.config\n    └── saved_model\n        ├── assets\n        ├── saved_model.pb\n        └── variables\n            ├── variables.data-00000-of-00001\n            └── variables.index\n```\n\nAt this moment we have a `saved_model` that may be used for inference.\n\n## 🚀 Using the Exported Model\n\nLet's see how can we use the saved model from the previous step for object detections.\n\nFirst, we need to create a detection function that will use the saved model. It will accept the image and will output the detected objects:\n\n```python\nimport time\nimport math\n\nPATH_TO_SAVED_MODEL = 'exported/ssd_mobilenet_v2_fpnlite_640x640_coco17_tpu-8/saved_model'\n\ndef detection_function_from_saved_model(saved_model_path):\n    print('Loading saved model...', end='')\n    start_time = time.time()\n\n    # Load saved model and build the detection function\n    detect_fn = tf.saved_model.load(saved_model_path)\n\n    end_time = time.time()\n    elapsed_time = end_time - start_time\n\n    print('Done! Took {} seconds'.format(math.ceil(elapsed_time)))\n\n    return detect_fn\n\nexported_detect_fn = detection_function_from_saved_model(\n    PATH_TO_SAVED_MODEL\n)\n```\n\n_output →_\n\n```\nLoading saved model...Done! Took 9 seconds\n```\n\nTo map the IDs of the detected classes back to the class names we need to load the label map as well:\n\n```python\nfrom object_detection.utils import label_map_util\n\ncategory_index = label_map_util.create_category_index_from_labelmap(\n    'dataset/printed_links/labels/label_map.pbtxt',\n    use_display_name=True\n)\n\nprint(category_index)\n```\n\n_output →_\n\n```\n{1: {'id': 1, 'name': 'http'}}\n```\n\nTesting the model on a test dataset.\n\n```python\nimport matplotlib.pyplot as plt\nimport tensorflow as tf\nimport numpy as np\n\nfrom object_detection.utils import visualization_utils\nfrom object_detection.data_decoders.tf_example_decoder import TfExampleDecoder\n\n%matplotlib inline\n\ndef tensors_from_tfrecord(\n    tfrecords_filename,\n    tfrecords_num,\n    dtype=tf.float32\n):\n    decoder = TfExampleDecoder()\n    raw_dataset = tf.data.TFRecordDataset(tfrecords_filename)\n    images = []\n\n    for raw_record in raw_dataset.take(tfrecords_num):\n        example = decoder.decode(raw_record)\n        image = example['image']\n        image = tf.cast(image, dtype=dtype)\n        images.append(image)\n\n    return images\n\ndef test_detection(tfrecords_filename, tfrecords_num, detect_fn):\n    image_tensors = tensors_from_tfrecord(\n        tfrecords_filename,\n        tfrecords_num,\n        dtype=tf.uint8\n    )\n\n    for image_tensor in image_tensors:\n        image_np = image_tensor.numpy()\n\n        # The model expects a batch of images, so add an axis with `tf.newaxis`.\n        input_tensor = tf.expand_dims(image_tensor, 0)\n\n        detections = detect_fn(input_tensor)\n\n        # All outputs are batches tensors.\n        # Convert to numpy arrays, and take index [0] to remove the batch dimension.\n        # We're only interested in the first num_detections.\n        num_detections = int(detections.pop('num_detections'))\n\n        detections = {key: value[0, :num_detections].numpy() for key, value in detections.items()}\n        detections['num_detections'] = num_detections\n\n        # detection_classes should be ints.\n        detections['detection_classes'] = detections['detection_classes'].astype(np.int64)\n\n        image_np_with_detections = image_np.astype(int).copy()\n\n        visualization_utils.visualize_boxes_and_labels_on_image_array(\n            image_np_with_detections,\n            detections['detection_boxes'],\n            detections['detection_classes'],\n            detections['detection_scores'],\n            category_index,\n            use_normalized_coordinates=True,\n            max_boxes_to_draw=100,\n            min_score_thresh=.3,\n            agnostic_mode=False\n        )\n\n        plt.figure(figsize=(8, 8))\n        plt.imshow(image_np_with_detections)\n\n    plt.show()\n\n\ntest_detection(\n    tfrecords_filename='dataset/printed_links/tfrecords/test.record',\n    tfrecords_num=10,\n    detect_fn=exported_detect_fn\n)\n```\n\nAs a result, you should see `10` images from the test dataset and highlighted `https:` prefixes that were detected by the model:\n\n![Testing the model on a test dataset](assets/25.jpg)\n\nThe fact that the model is able to detect custom objects (in our case the `https://` prefixes) on the images it hasn't seen before is a good sign and something that we wanted to achieve.\n\n## 🗜 Converting the Model for Web\n\nAs you remember from the beginning of this article, our goal was to use the custom object detection model in the browser. Luckily, there is a [TensorFlow.js](https://www.tensorflow.org/js) JavaScript version of the TensorFlow library exists. In JavaScript, we can't work with our saved model directly. Instead, we need to convert it to [tfjs_graph_model](https://www.tensorflow.org/js/tutorials/conversion/import_saved_model) format.\n\nTo do this we need to install the tensorflowjs Python package:\n\n```bash\npip install tensorflowjs --quiet\n```\n\nThe model may be exported like this:\n\n```bash\n%%bash\n\ntensorflowjs_converter \\\n    --input_format=tf_saved_model \\\n    --output_format=tfjs_graph_model \\\n    exported/ssd_mobilenet_v2_fpnlite_640x640_coco17_tpu-8/saved_model \\\n    exported_web/ssd_mobilenet_v2_fpnlite_640x640_coco17_tpu-8\n```\n\nThe `exported_web` folder contains the `.json` file with the model metadata and a bunch of `.bin` files with trained model parameters:\n\n```\nexported_web\n└── ssd_mobilenet_v2_fpnlite_640x640_coco17_tpu-8\n    ├── group1-shard1of4.bin\n    ├── group1-shard2of4.bin\n    ├── group1-shard3of4.bin\n    ├── group1-shard4of4.bin\n    └── model.json\n```\n\nFinally, we have the model that is able to detect `https://` prefixes for us, and it is saved in JavaScript-understandable format.\n\nLet's check the model size to see if it is light enough to be loaded completely to the client-side:\n\n```python\nimport pathlib\n\ndef get_folder_size(folder_path):\n    mB = 1000000\n    root_dir = pathlib.Path(folder_path)\n    sizeBytes = sum(f.stat().st_size for f in root_dir.glob('**/*') if f.is_file())\n    return f'{sizeBytes//mB} MB'\n\n\nprint(f'Original model size:      {get_folder_size(\"cache/datasets/ssd_mobilenet_v2_fpnlite_640x640_coco17_tpu-8\")}')\nprint(f'Exported model size:      {get_folder_size(\"exported/ssd_mobilenet_v2_fpnlite_640x640_coco17_tpu-8\")}')\nprint(f'Exported WEB model size:  {get_folder_size(\"exported_web/ssd_mobilenet_v2_fpnlite_640x640_coco17_tpu-8\")}')\n```\n\n_output →_\n\n```\nOriginal model size:      31 MB\nExported model size:      28 MB\nExported WEB model size:  13 MB\n```\n\nAs you may see the model that we're going to use for the Web has `13MB` which is quite acceptable in our case.\n\nLater in JavaScript we may start using the model like this:\n\n```javascript\nimport * as tf from '@tensorflow/tfjs';\nconst model = await tf.loadGraphModel(modelURL);\n```\n\n> 🧭 The next step is to implement the Links Detector UI which will use this model, but this is another story for another article. The final source code of the application may be found in [links-detector repository](https://github.com/trekhleb/links-detector) on GitHub.\n\n## 🤔 Conclusions\n\nIn this article, we started to solve the issue with printed links detection. We ended up creating the custom object detector to recognize the `https://` prefixes on text images (i.e. on smartphone camera stream images). We have also converted the model to a `tfjs_graph_model` to be able to re-use it on the client-side.\n\nYou may 🚀 [launch Links Detector demo](https://trekhleb.dev/links-detector/) from your smartphone to see the final result and to try how the model performs on your books or magazines.\n\nHere is how the final solution looks like:\n\n![Links Detector Demo](assets/26.gif)\n\nYou may also 📝 [browse the links-detector repository](https://github.com/trekhleb/links-detector) on GitHub to see the complete source code of the UI part of the application.\n\n> ⚠️ Currently the application is in _experimental_ _Alpha_ stage and has [many issues and limitations](https://github.com/trekhleb/links-detector/issues?q=is%3Aopen+is%3Aissue+label%3Aenhancement). So don't raise your expectations level too high until these issues are resolved 🤷🏻‍.\n\nAs the next steps which might improve the model performance we might do the following:\n\n- Extend the dataset with more link types (`http://`, `tcp://`, `ftp://` etc)\n- Extended the dataset with images that have dark backgrounds\n- Extend the dataset with underlined links\n- Extend the dataset with examples of different fonts and ligatures\n- etc.\n\nEven though the model has a lot to be improved to make it closer to the production-ready state, I still hope that this article was useful for you and gave you some guidelines and inspiration to play around with your custom object detectors.\n\nHappy training, folks!\n\n","fields":{"slug":"/blog/2020/printed-links-detection/"},"internal":{"contentFilePath":"/home/runner/work/trekhleb.github.io/trekhleb.github.io/src/posts/2020/printed-links-detection/index.md"},"frontmatter":{"title":"Making the Printed Links Clickable Using TensorFlow 2 Object Detection API","summary":"In this article we will start solving the issue of making the printed links (i.e. in a book or in a magazine) clickable via your smartphone camera","date":"01 December, 2020","cover":{"childImageSharp":{"gatsbyImageData":{"layout":"fullWidth","backgroundColor":"#080808","images":{"fallback":{"src":"/static/55a94699f1c16ff59258cbb490d497eb/8fe9a/01-cover.png","srcSet":"/static/55a94699f1c16ff59258cbb490d497eb/b8c2b/01-cover.png 750w,\n/static/55a94699f1c16ff59258cbb490d497eb/5b74c/01-cover.png 1080w,\n/static/55a94699f1c16ff59258cbb490d497eb/8fe9a/01-cover.png 1280w","sizes":"100vw"},"sources":[{"srcSet":"/static/55a94699f1c16ff59258cbb490d497eb/b41a5/01-cover.webp 750w,\n/static/55a94699f1c16ff59258cbb490d497eb/c3fee/01-cover.webp 1080w,\n/static/55a94699f1c16ff59258cbb490d497eb/bf6d1/01-cover.webp 1280w","type":"image/webp","sizes":"100vw"}]},"width":1,"height":0.5}}}}}},"pageContext":{"slug":"/blog/2020/printed-links-detection/","frontmatter":{"title":"Making the Printed Links Clickable Using TensorFlow 2 Object Detection API","summary":"In this article we will start solving the issue of making the printed links (i.e. in a book or in a magazine) clickable via your smartphone camera","cover":"assets/01-cover.png","date":"2020-12-01T00:00:00.000Z"}}},"staticQueryHashes":[],"slicesMap":{}}